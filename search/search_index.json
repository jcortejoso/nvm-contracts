{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Nevermined Contracts Documentation \u00b6 The Nevermined Contracts are organized in different modules. Each of them is intended to keep different Solidity Smart Contracts code providing different building blocks or capabilities to implement the Nevermined Business Logic. Modules \u00b6 Registry \u00b6 It allows the registration of assets into a Nevermined network. The entry point for that is the DIDRegistry contract. It allows to The different contracts involved in the Registry module are: DID Registry DID Factory NFT Upgradeable DIDRegistry Library Provenance Registry Service Agreement Templates \u00b6 This are the templates used for the end users to define use cases or user flows. They implement a pre-defined user flow implementing a use case (like selling access to data). Every different service agreement template allows to create instances of their type by the users with custimzed conditions. The existing templates existing are: Access Template Compute Execution Template DID Sales Template NFT Sales Template NFT Access Template Dynamic Access Template A part of this, the agreements contracts module provide some internal components to manage the registering of service agreements on-chain. This contracts typically don't need be instantiated directly by end-users: Agreement Store Manager Agreement Store Library Service Agreement Conditions \u00b6 Are the different conditions allowing to the users of a flow to define the ground rules as part of an agreement. Conditions typically have different parameters allowing to the users to define the specific conditions that someone executing an agreement needs to fulfill. The combination of templates and agreements allow the definition of complex scenarios where the users can interact and transact regarding Nevermined digital assets. The existing conditions ready to be used are: Access Condition Lock Payment Condition Rewards Reward Escrow Payment Compute Execution Condition Hash Lock Condition NFT Access Condition NFT Holder Condition NFT Lock Condition Transfer DID Ownership Condition Transfer NFT Condition Sign Condition Whitelisting Condition Threshold Condition Token \u00b6 This are the contracts providing the following capabilities: Nevermined Token - A reference implementation of a ERC20 token. This NVM token is provided as default token in a Nevermined deployment. The usage of this token is not necessary. A different ERC20 can be used depending on the deployment of the network or the configuration of the service agreements. This allows to support payments in the NVM token, a different ERC20 token or in ETH . Dispenser - It allows the distribution of ERC20 tokens (typically NVM token) in a testnet. Because of that, the Dispenser contract is not deployed in production or mainnet networks . Libraries \u00b6 EpochLibrary HashListLibrary Common Hash List Contract Interfaces \u00b6 IList ISecret Store ISecret Store Permission Template Libraries \u00b6 Allow the registration and management of Service Agreement Templates. Typically are not necessary by users, that can make use of the already pre-defined service agreement templates. Template Store Manager Template Store Library Agreement Template Condition Libraries \u00b6 Internal libraries allowing the management and support of conditions. Condition Store Manager Condition Store Library Condition Base Contract","title":"Nevermined Contracts Documentation"},{"location":"#nevermined-contracts-documentation","text":"The Nevermined Contracts are organized in different modules. Each of them is intended to keep different Solidity Smart Contracts code providing different building blocks or capabilities to implement the Nevermined Business Logic.","title":"Nevermined Contracts Documentation"},{"location":"#modules","text":"","title":"Modules"},{"location":"#registry","text":"It allows the registration of assets into a Nevermined network. The entry point for that is the DIDRegistry contract. It allows to The different contracts involved in the Registry module are: DID Registry DID Factory NFT Upgradeable DIDRegistry Library Provenance Registry","title":"Registry"},{"location":"#service-agreement-templates","text":"This are the templates used for the end users to define use cases or user flows. They implement a pre-defined user flow implementing a use case (like selling access to data). Every different service agreement template allows to create instances of their type by the users with custimzed conditions. The existing templates existing are: Access Template Compute Execution Template DID Sales Template NFT Sales Template NFT Access Template Dynamic Access Template A part of this, the agreements contracts module provide some internal components to manage the registering of service agreements on-chain. This contracts typically don't need be instantiated directly by end-users: Agreement Store Manager Agreement Store Library","title":"Service Agreement Templates"},{"location":"#service-agreement-conditions","text":"Are the different conditions allowing to the users of a flow to define the ground rules as part of an agreement. Conditions typically have different parameters allowing to the users to define the specific conditions that someone executing an agreement needs to fulfill. The combination of templates and agreements allow the definition of complex scenarios where the users can interact and transact regarding Nevermined digital assets. The existing conditions ready to be used are: Access Condition Lock Payment Condition Rewards Reward Escrow Payment Compute Execution Condition Hash Lock Condition NFT Access Condition NFT Holder Condition NFT Lock Condition Transfer DID Ownership Condition Transfer NFT Condition Sign Condition Whitelisting Condition Threshold Condition","title":"Service Agreement Conditions"},{"location":"#token","text":"This are the contracts providing the following capabilities: Nevermined Token - A reference implementation of a ERC20 token. This NVM token is provided as default token in a Nevermined deployment. The usage of this token is not necessary. A different ERC20 can be used depending on the deployment of the network or the configuration of the service agreements. This allows to support payments in the NVM token, a different ERC20 token or in ETH . Dispenser - It allows the distribution of ERC20 tokens (typically NVM token) in a testnet. Because of that, the Dispenser contract is not deployed in production or mainnet networks .","title":"Token"},{"location":"#libraries","text":"EpochLibrary HashListLibrary Common Hash List","title":"Libraries"},{"location":"#contract-interfaces","text":"IList ISecret Store ISecret Store Permission","title":"Contract Interfaces"},{"location":"#template-libraries","text":"Allow the registration and management of Service Agreement Templates. Typically are not necessary by users, that can make use of the already pre-defined service agreement templates. Template Store Manager Template Store Library Agreement Template","title":"Template Libraries"},{"location":"#condition-libraries","text":"Internal libraries allowing the management and support of conditions. Condition Store Manager Condition Store Library Condition Base Contract","title":"Condition Libraries"},{"location":"Packages/","text":"Packaging \u00b6 The following package describes how to package the Keeper Contracts in different formats. It is helpful to distribute the compiled smart contracts ABI's in different \"flavours\". It allows to import those ABI's from different languages enabling an easier interaction with the Keeper. Javascript (NPM) \u00b6 NPM packages are published as part of the Nevermined NPM organization . Github Actions is configured to release a new version of the nevermined-io/contracts NPM library after tagging. Versions of the library must be modified in the package.json file. { \"name\" : \"@nevermined-io/contracts\" , \"version\" : \"1.0.0\" , .. } Typically you can't overwrite NPM already published versions of the libraries. This package uses Semantic Versioning , so if you are testing with new versions, it's recommended to play with the patch numbers. If you need to build a local version of the package you need to run the following commands: yarn yarn build If you need to release a new version of the library before tagging, you need to execute the following command: npm publish --access public To do that you need to be an authorized user in the NPM Nevermined organization. Python \u00b6 Python packages are generated automatically in Pypi format: https://pypi.org/project/nevermined-contracts/ Java \u00b6 Java packages are generated automatically for JVM applications and published into Maven central: https://search.maven.org/artifact/io.keyko.nevermined/contracts","title":"Packaging"},{"location":"Packages/#packaging","text":"The following package describes how to package the Keeper Contracts in different formats. It is helpful to distribute the compiled smart contracts ABI's in different \"flavours\". It allows to import those ABI's from different languages enabling an easier interaction with the Keeper.","title":"Packaging"},{"location":"Packages/#javascript-npm","text":"NPM packages are published as part of the Nevermined NPM organization . Github Actions is configured to release a new version of the nevermined-io/contracts NPM library after tagging. Versions of the library must be modified in the package.json file. { \"name\" : \"@nevermined-io/contracts\" , \"version\" : \"1.0.0\" , .. } Typically you can't overwrite NPM already published versions of the libraries. This package uses Semantic Versioning , so if you are testing with new versions, it's recommended to play with the patch numbers. If you need to build a local version of the package you need to run the following commands: yarn yarn build If you need to release a new version of the library before tagging, you need to execute the following command: npm publish --access public To do that you need to be an authorized user in the NPM Nevermined organization.","title":"Javascript (NPM)"},{"location":"Packages/#python","text":"Python packages are generated automatically in Pypi format: https://pypi.org/project/nevermined-contracts/","title":"Python"},{"location":"Packages/#java","text":"Java packages are generated automatically for JVM applications and published into Maven central: https://search.maven.org/artifact/io.keyko.nevermined/contracts","title":"Java"},{"location":"ReleaseProcess/","text":"Release Process \u00b6 Build a new version \u00b6 The steps to build a new version are the following: Create a new local feature branch, e.g. git checkout -b release/v0.2.5 Use the bumpversion.sh script to bump the project version. You can execute the script using {major|minor|patch} as first argument to bump the version accordingly: To bump the patch version: ./bumpversion.sh patch To bump the minor version: ./bumpversion.sh minor To bump the major version: ./bumpversion.sh major assuming we are on version v0.2.4 and the desired version is v0.2.5 ./bumpversion.sh patch has to be run. Interact with networks \u00b6 Roles \u00b6 We define four roles: deployer : represented as accounts[0] upgrader : represented as accounts[1] upgraderWallet : represented as the upgrader from wallets.json ownerWallet : represented as the owner from wallets.json Flags \u00b6 --testnet Deploys the Dispenser, the NeverminedToken and the contracts from contracts.json --with-token Deploys the NeverminedToken and the contracts from contracts.json Deployer \u00b6 Can be any account. It is used for deploying the initial proxy contracts and the logic contracts. Upgrader \u00b6 Has to be an owner of the upgrader multi sig wallet. It is used for issuing upgrade requests against the upgrader multi sig wallet. UpgraderWallet \u00b6 One instance of the multi sig wallet, defined as upgrader . This wallet will be assigned as zos admin and is required to do upgrades. OwnerWallet \u00b6 One instance of the multi sig wallet, defined as owner . This wallet will be assigned as the owner of all the contracts. It can be used to call specific functions in the contracts ie. change the configuration. Deploy & Upgrade \u00b6 run yarn clean to clean the work dir. run yarn compile to compile the contracts. Rinkeby (Testnet) \u00b6 Copy the wallet file for rinkeby cp wallets_rinkeby.json wallets.json run export MNEMONIC=<your rinkeby mnemonic> . You will find them in the password manager. Deploy the whole application \u00b6 To deploy all contracts run yarn deploy:rinkeby Deploy a single contracts \u00b6 To deploy a single contract you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:rinkeby -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser . Upgrade the whole application \u00b6 To upgrade all contracts run yarn upgrade:rinkeby Upgrade a single contract \u00b6 To upgrade a single contract run yarn upgrade:rinkeby -- NeverminedToken . For upgrading the NeverminedToken contract. Persist artifacts \u00b6 Commit all changes in artifacts/*.rinkeby.json Mumbai (PolygonTestnet) \u00b6 Copy the wallet file for mumbai cp wallets_mumbai.json wallets.json run export MNEMONIC=<your mumbai mnemonic> . You will find them in the password manager. Deploy the whole application \u00b6 To deploy all contracts run yarn deploy:mumbai Deploy a single contracts \u00b6 To deploy a single contract you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:mumbai -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser . Upgrade the whole application \u00b6 To upgrade all contracts run yarn upgrade:mumbai Upgrade a single contract \u00b6 To upgrade a single contract run yarn upgrade:mumbai -- NeverminedToken . For upgrading the NeverminedToken contract. Persist artifacts \u00b6 Commit all changes in artifacts/*.mumbai.json Kovan (Testnet) \u00b6 Copy the wallet file for kovan > cp wallets_kovan.json wallets.json run export MNEMONIC=<your kovan mnemonic> . You will find them in the password manager. run export INFURA_TOKEN=<your infura token> . You will get it from infura . Deploy the whole application \u00b6 To deploy all the contracts run yarn deploy:kovan Deploy a single contracts \u00b6 To deploy a single contracts you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:kovan -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser . Upgrade the whole application \u00b6 To upgrade all contracts run yarn upgrade:kovan Upgrade a single contract \u00b6 To upgrade a single contract run yarn upgrade:kovan -- NeverminedToken . For upgrading the NeverminedToken contract. Persist artifacts \u00b6 Commit all changes in artifacts/*.kovan.json Approve upgrades \u00b6 All upgrades of the contracts have to be approved by the upgrader wallet configured in the wallets.json file. go to https://wallet.gnosis.pm Load upgrader wallet Select an Ethereum Account that is an owner of the multi sig wallet, but not the one who issued the upgrade request. This can be done in the following ways: Connect to a local Blockchain node that holds the private key. Connect to MetaMask and select the owner account from the multi sig wallet. Connect a hardware wallet like ledger or trezor. Select the transaction you want to confirm (the upgrade script will tell you which transactions have to be approved in which wallets) Click Confirm Document \u00b6 Contracts documentation \u00b6 Update the contracts documentation run yarn doc:contracts Commit the changes in docs/contracts folder Address Documentation \u00b6 Update the addresses in the README.md run node ./scripts/contracts/get-addresses.js <network name> It will output the current proxy addresses in the README friendly format. | AccessCondition | v0.9.0 | 0x45DE141F8Efc355F1451a102FB6225F1EDd2921d | | AgreementStoreManager | v0.9.0 | 0x62f84700b1A0ea6Bfb505aDC3c0286B7944D247C | | ConditionStoreManager | v0.9.0 | 0x39b0AA775496C5ebf26f3B81C9ed1843f09eE466 | | DIDRegistry | v0.9.0 | 0x4A0f7F763B1A7937aED21D63b2A78adc89c5Db23 | | DIDRegistryLibrary | v0.9.0 | 0x3B3504908Db36f5D5f07CD420ee2BBBbDfB674cF | | Dispenser | v0.9.0 | 0x865396b7ddc58C693db7FCAD1168E3BD95Fe3368 | .... Copy this to the README.md Trigger CI \u00b6 Commit the missing changes to the feature branch. Tag the last commit with the new version number ie. v0.2.5 Push the feature branch to GitHub. Make a pull request from the just-pushed branch to develop branch. Wait for all the tests to pass! Merge the pull request into the develop branch. Release and packages \u00b6 The release itself is done by github actions based on the tagged commit. It will deploy the following components: npm pypi maven docker The npm, pypi and maven packages contain the contract artifacts for the contracts already deployed in different networks (such as Production , Rinkeby , Mumbai , Testing , or Spree ). The docker image generated contains the contracts and script ready to be used to deploy the contracts to a network. It is used for deploying the contracts in the local network Spree in nevermined-io/tools Once the new version is tagged and released, you can edit the Releases section of GitHub with the information and changes about the new version (in the future, these will come from the changelog): Audit \u00b6 To check or document that all transactions have been approved in the multi sig wallet you can run yarn audit:rinkeby to get a list of all the current transactions and their current status. Wallet: 0x24EB26D4042a2AB576E7E39b87c3f33f276AeF92 Transaction ID: 64 Destination: 0xfA16d26e9F4fffC6e40963B281a0bB08C31ed40C Contract: EscrowAccessSecretStoreTemplate Data is `upgradeTo` call: true Confirmed from: 0x7A13E1aD23546c9b804aDFd13e9AcB184EfCAF58 Executed: false","title":"Release Process"},{"location":"ReleaseProcess/#release-process","text":"","title":"Release Process"},{"location":"ReleaseProcess/#build-a-new-version","text":"The steps to build a new version are the following: Create a new local feature branch, e.g. git checkout -b release/v0.2.5 Use the bumpversion.sh script to bump the project version. You can execute the script using {major|minor|patch} as first argument to bump the version accordingly: To bump the patch version: ./bumpversion.sh patch To bump the minor version: ./bumpversion.sh minor To bump the major version: ./bumpversion.sh major assuming we are on version v0.2.4 and the desired version is v0.2.5 ./bumpversion.sh patch has to be run.","title":"Build a new version"},{"location":"ReleaseProcess/#interact-with-networks","text":"","title":"Interact with networks"},{"location":"ReleaseProcess/#roles","text":"We define four roles: deployer : represented as accounts[0] upgrader : represented as accounts[1] upgraderWallet : represented as the upgrader from wallets.json ownerWallet : represented as the owner from wallets.json","title":"Roles"},{"location":"ReleaseProcess/#flags","text":"--testnet Deploys the Dispenser, the NeverminedToken and the contracts from contracts.json --with-token Deploys the NeverminedToken and the contracts from contracts.json","title":"Flags"},{"location":"ReleaseProcess/#deployer","text":"Can be any account. It is used for deploying the initial proxy contracts and the logic contracts.","title":"Deployer"},{"location":"ReleaseProcess/#upgrader","text":"Has to be an owner of the upgrader multi sig wallet. It is used for issuing upgrade requests against the upgrader multi sig wallet.","title":"Upgrader"},{"location":"ReleaseProcess/#upgraderwallet","text":"One instance of the multi sig wallet, defined as upgrader . This wallet will be assigned as zos admin and is required to do upgrades.","title":"UpgraderWallet"},{"location":"ReleaseProcess/#ownerwallet","text":"One instance of the multi sig wallet, defined as owner . This wallet will be assigned as the owner of all the contracts. It can be used to call specific functions in the contracts ie. change the configuration.","title":"OwnerWallet"},{"location":"ReleaseProcess/#deploy-upgrade","text":"run yarn clean to clean the work dir. run yarn compile to compile the contracts.","title":"Deploy &amp; Upgrade"},{"location":"ReleaseProcess/#rinkeby-testnet","text":"Copy the wallet file for rinkeby cp wallets_rinkeby.json wallets.json run export MNEMONIC=<your rinkeby mnemonic> . You will find them in the password manager.","title":"Rinkeby (Testnet)"},{"location":"ReleaseProcess/#deploy-the-whole-application","text":"To deploy all contracts run yarn deploy:rinkeby","title":"Deploy the whole application"},{"location":"ReleaseProcess/#deploy-a-single-contracts","text":"To deploy a single contract you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:rinkeby -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser .","title":"Deploy a single contracts"},{"location":"ReleaseProcess/#upgrade-the-whole-application","text":"To upgrade all contracts run yarn upgrade:rinkeby","title":"Upgrade the whole application"},{"location":"ReleaseProcess/#upgrade-a-single-contract","text":"To upgrade a single contract run yarn upgrade:rinkeby -- NeverminedToken . For upgrading the NeverminedToken contract.","title":"Upgrade a single contract"},{"location":"ReleaseProcess/#persist-artifacts","text":"Commit all changes in artifacts/*.rinkeby.json","title":"Persist artifacts"},{"location":"ReleaseProcess/#mumbai-polygontestnet","text":"Copy the wallet file for mumbai cp wallets_mumbai.json wallets.json run export MNEMONIC=<your mumbai mnemonic> . You will find them in the password manager.","title":"Mumbai (PolygonTestnet)"},{"location":"ReleaseProcess/#deploy-the-whole-application_1","text":"To deploy all contracts run yarn deploy:mumbai","title":"Deploy the whole application"},{"location":"ReleaseProcess/#deploy-a-single-contracts_1","text":"To deploy a single contract you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:mumbai -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser .","title":"Deploy a single contracts"},{"location":"ReleaseProcess/#upgrade-the-whole-application_1","text":"To upgrade all contracts run yarn upgrade:mumbai","title":"Upgrade the whole application"},{"location":"ReleaseProcess/#upgrade-a-single-contract_1","text":"To upgrade a single contract run yarn upgrade:mumbai -- NeverminedToken . For upgrading the NeverminedToken contract.","title":"Upgrade a single contract"},{"location":"ReleaseProcess/#persist-artifacts_1","text":"Commit all changes in artifacts/*.mumbai.json","title":"Persist artifacts"},{"location":"ReleaseProcess/#kovan-testnet","text":"Copy the wallet file for kovan > cp wallets_kovan.json wallets.json run export MNEMONIC=<your kovan mnemonic> . You will find them in the password manager. run export INFURA_TOKEN=<your infura token> . You will get it from infura .","title":"Kovan (Testnet)"},{"location":"ReleaseProcess/#deploy-the-whole-application_2","text":"To deploy all the contracts run yarn deploy:kovan","title":"Deploy the whole application"},{"location":"ReleaseProcess/#deploy-a-single-contracts_2","text":"To deploy a single contracts you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:kovan -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser .","title":"Deploy a single contracts"},{"location":"ReleaseProcess/#upgrade-the-whole-application_2","text":"To upgrade all contracts run yarn upgrade:kovan","title":"Upgrade the whole application"},{"location":"ReleaseProcess/#upgrade-a-single-contract_2","text":"To upgrade a single contract run yarn upgrade:kovan -- NeverminedToken . For upgrading the NeverminedToken contract.","title":"Upgrade a single contract"},{"location":"ReleaseProcess/#persist-artifacts_2","text":"Commit all changes in artifacts/*.kovan.json","title":"Persist artifacts"},{"location":"ReleaseProcess/#approve-upgrades","text":"All upgrades of the contracts have to be approved by the upgrader wallet configured in the wallets.json file. go to https://wallet.gnosis.pm Load upgrader wallet Select an Ethereum Account that is an owner of the multi sig wallet, but not the one who issued the upgrade request. This can be done in the following ways: Connect to a local Blockchain node that holds the private key. Connect to MetaMask and select the owner account from the multi sig wallet. Connect a hardware wallet like ledger or trezor. Select the transaction you want to confirm (the upgrade script will tell you which transactions have to be approved in which wallets) Click Confirm","title":"Approve upgrades"},{"location":"ReleaseProcess/#document","text":"","title":"Document"},{"location":"ReleaseProcess/#contracts-documentation","text":"Update the contracts documentation run yarn doc:contracts Commit the changes in docs/contracts folder","title":"Contracts documentation"},{"location":"ReleaseProcess/#address-documentation","text":"Update the addresses in the README.md run node ./scripts/contracts/get-addresses.js <network name> It will output the current proxy addresses in the README friendly format. | AccessCondition | v0.9.0 | 0x45DE141F8Efc355F1451a102FB6225F1EDd2921d | | AgreementStoreManager | v0.9.0 | 0x62f84700b1A0ea6Bfb505aDC3c0286B7944D247C | | ConditionStoreManager | v0.9.0 | 0x39b0AA775496C5ebf26f3B81C9ed1843f09eE466 | | DIDRegistry | v0.9.0 | 0x4A0f7F763B1A7937aED21D63b2A78adc89c5Db23 | | DIDRegistryLibrary | v0.9.0 | 0x3B3504908Db36f5D5f07CD420ee2BBBbDfB674cF | | Dispenser | v0.9.0 | 0x865396b7ddc58C693db7FCAD1168E3BD95Fe3368 | .... Copy this to the README.md","title":"Address Documentation"},{"location":"ReleaseProcess/#trigger-ci","text":"Commit the missing changes to the feature branch. Tag the last commit with the new version number ie. v0.2.5 Push the feature branch to GitHub. Make a pull request from the just-pushed branch to develop branch. Wait for all the tests to pass! Merge the pull request into the develop branch.","title":"Trigger CI"},{"location":"ReleaseProcess/#release-and-packages","text":"The release itself is done by github actions based on the tagged commit. It will deploy the following components: npm pypi maven docker The npm, pypi and maven packages contain the contract artifacts for the contracts already deployed in different networks (such as Production , Rinkeby , Mumbai , Testing , or Spree ). The docker image generated contains the contracts and script ready to be used to deploy the contracts to a network. It is used for deploying the contracts in the local network Spree in nevermined-io/tools Once the new version is tagged and released, you can edit the Releases section of GitHub with the information and changes about the new version (in the future, these will come from the changelog):","title":"Release and packages"},{"location":"ReleaseProcess/#audit","text":"To check or document that all transactions have been approved in the multi sig wallet you can run yarn audit:rinkeby to get a list of all the current transactions and their current status. Wallet: 0x24EB26D4042a2AB576E7E39b87c3f33f276AeF92 Transaction ID: 64 Destination: 0xfA16d26e9F4fffC6e40963B281a0bB08C31ed40C Contract: EscrowAccessSecretStoreTemplate Data is `upgradeTo` call: true Confirmed from: 0x7A13E1aD23546c9b804aDFd13e9AcB184EfCAF58 Executed: false","title":"Audit"},{"location":"Upgrades/","text":"Upgrade Process \u00b6 This documents explains in detail how nevermined-contracts should be deployed using zeppelinOS and how the contracts can be upgraded. The latest section describes the test procedure. Quickstart \u00b6 The first step to work with zos is to install dependencies then initialize the project. Then compile contracts and add contracts to the project. Finally push the contracts into the network and create the upgradable instances. Once the contracts are deployed they can be tested and upgraded. Also we change the proxy administrator to a MultiSignature wallet to approve upgrades. We are going to use the Nevermined Contract Tools in order to perform any future deployments/upgrades. Details \u00b6 Here we provide more details into each step of the initial deploy and the approach of upgradeability and governance. Roles \u00b6 Before going into more details about the deployment. We should differentiate between different roles in the system which govern the upgradeability in nevermined-contracts. Roles are defined as follows: deployer: represented as accounts[0] upgrader: represented as accounts[1] upgraderWallet: represented as the upgrader from wallets.json ownerWallet: represented as the owner from wallets.json - Deployer : Can be any account. It is used for deploying the initial proxy contracts and the logic contracts . Upgrader : Has to be an owner of the upgrader multi sig wallet. It is used for issuing upgrade requests against the upgrader multi sig wallet. UpgraderWallet : One instance of the multi sig wallet, defined as upgrader . This wallet will be assigned as zos admin and is required to do upgrades. OwnerWallet : One instance of the multi sig wallet, defined as owner . This wallet will be assigned as the owner of all the contracts. It can be used to call specific functions in the contracts ie. change the configuration. Deploy & Upgrade \u00b6 zos does not support migrations, hence all the initial configuration should be performed with Nevermined Contract Tools . Contract constructors are ignored so the initial setup of the contract should be made in a initialize function that will be executed only once after the initial deployment. 1. Configuration \u00b6 Nevermined Contract Tools checks the contracts.json in order to detect the current contracts that are going to be deployed: [ \"ConditionStoreManager\" , \"TemplateStoreManager\" , \"AgreementStoreManager\" , \"SignCondition\" , \"HashLockCondition\" , \"LockRewardCondition\" , \"NFTHolderCondition\" , \"AccessCondition\" , \"EscrowReward\" , \"EscrowAccessSecretStoreTemplate\" , \"NFTAccessTemplate\" , \"DIDRegistry\" ] Moreover for each network, Nevermined Contract Tools needs to detect the roles and their addresses from a pre-defined wallets config file. The following configuration should be an example for wallets-<NETWORK_NAME>.json : [ { \"name\" : \"upgrader\" , \"address\" : \"0x24eb26d4042a2ab576e7e39b87c3f33f276aef92\" }, { \"name\" : \"owner\" , \"address\" : \"0xd02d68c62401472ce35ba3c7e505deae62db2b8b\" } ] 2. Preparation \u00b6 The following commands clean, install dependencies and compile the contracts: $ yarn clean #to clean the work dir $ yarn #install dependencies $ yarn compile #to compile the contracts 3. Deploy & Upgrade \u00b6 The following steps shows how to perform contracts deployment and upgrade on Rinkeby and Kovan networks. Nile \u00b6 Copy the wallet file for rinkeby cp wallets_rinkeby.json wallets.json run export MNEMONIC=<your staging mnemonic> . You will find them in the password manager. Deploy the whole application \u00b6 To deploy all contracts run yarn deploy:rinkeby Deploy a single contracts \u00b6 To deploy a single contract you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:rinkeby -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser . Upgrade the whole application \u00b6 To upgrade all contracts run yarn upgrade:rinkeby Upgrade a single contract \u00b6 To upgrade a single contract run yarn upgrade:rinkeby -- NeverminedToken . For upgrading the NeverminedToken contract. Persist artifacts \u00b6 Commit all changes in artifacts/*.rinkeby.json Kovan \u00b6 Copy the wallet file for kovan > cp wallets_kovan.json wallets.json run export MNEMONIC=<your kovan mnemonic> . You will find them in the password manager. run export INFURA_TOKEN=<your infura token> . You will get it from infura . Deploy the whole application \u00b6 To deploy all the contracts run yarn deploy:kovan Deploy a single contracts \u00b6 To deploy a single contracts you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:kovan -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser . Upgrade the whole application \u00b6 To upgrade all contracts run yarn upgrade:kovan Upgrade a single contract \u00b6 To upgrade a single contract run yarn upgrade:kovan -- NeverminedToken . For upgrading the NeverminedToken contract. Persist artifacts \u00b6 Commit all changes in artifacts/*.kovan.json 4. Approve Upgrade(s) \u00b6 All upgrades of the contracts have to be approved by the upgrader wallet configured in the wallets.json file. go to https://wallet.gnosis.pm Load upgrader wallet Select an Ethereum Account that is an owner of the multi sig wallet, but not the one who issued the upgrade request. This can be done in the following ways: Connect to a local Blockchain node that holds the private key. Connect to MetaMask and select the owner account from the multi sig wallet. Connect a hardware wallet like ledger or trezor. Select the transaction you want to confirm (the upgrade script will tell you which transactions have to be approved in which wallets) Click Confirm 5. Audit Contracts \u00b6 To check or document that all transactions have been approved in the multi sig wallet you can run yarn audit:rinkeby to get a list of all the current transactions and their current status. Wallet: 0x24EB26D4042a2AB576E7E39b87c3f33f276AeF92 Transaction ID: 64 Destination: 0xfA16d26e9F4fffC6e40963B281a0bB08C31ed40C Contract: EscrowAccessSecretStoreTemplate Data is `upgradeTo` call: true Confirmed from: 0x7A13E1aD23546c9b804aDFd13e9AcB184EfCAF58 Executed: false 6. Documentation \u00b6 Update the addresses in the README.md run node ./scripts/contracts/get-addresses.js <network name> It will output the current proxy addresses in the README friendly format. | AccessCondition | v0.9.0 | 0x45DE141F8Efc355F1451a102FB6225F1EDd2921d | | AgreementStoreManager | v0.9.0 | 0x62f84700b1A0ea6Bfb505aDC3c0286B7944D247C | | ConditionStoreManager | v0.9.0 | 0x39b0AA775496C5ebf26f3B81C9ed1843f09eE466 | | DIDRegistry | v0.9.0 | 0x4A0f7F763B1A7937aED21D63b2A78adc89c5Db23 | | DIDRegistryLibrary | v0.9.0 | 0x3B3504908Db36f5D5f07CD420ee2BBBbDfB674cF | | Dispenser | v0.9.0 | 0x865396b7ddc58C693db7FCAD1168E3BD95Fe3368 | .... Copy this to the README.md","title":"Upgrade Process"},{"location":"Upgrades/#upgrade-process","text":"This documents explains in detail how nevermined-contracts should be deployed using zeppelinOS and how the contracts can be upgraded. The latest section describes the test procedure.","title":"Upgrade Process"},{"location":"Upgrades/#quickstart","text":"The first step to work with zos is to install dependencies then initialize the project. Then compile contracts and add contracts to the project. Finally push the contracts into the network and create the upgradable instances. Once the contracts are deployed they can be tested and upgraded. Also we change the proxy administrator to a MultiSignature wallet to approve upgrades. We are going to use the Nevermined Contract Tools in order to perform any future deployments/upgrades.","title":"Quickstart"},{"location":"Upgrades/#details","text":"Here we provide more details into each step of the initial deploy and the approach of upgradeability and governance.","title":"Details"},{"location":"Upgrades/#roles","text":"Before going into more details about the deployment. We should differentiate between different roles in the system which govern the upgradeability in nevermined-contracts. Roles are defined as follows: deployer: represented as accounts[0] upgrader: represented as accounts[1] upgraderWallet: represented as the upgrader from wallets.json ownerWallet: represented as the owner from wallets.json - Deployer : Can be any account. It is used for deploying the initial proxy contracts and the logic contracts . Upgrader : Has to be an owner of the upgrader multi sig wallet. It is used for issuing upgrade requests against the upgrader multi sig wallet. UpgraderWallet : One instance of the multi sig wallet, defined as upgrader . This wallet will be assigned as zos admin and is required to do upgrades. OwnerWallet : One instance of the multi sig wallet, defined as owner . This wallet will be assigned as the owner of all the contracts. It can be used to call specific functions in the contracts ie. change the configuration.","title":"Roles"},{"location":"Upgrades/#deploy-upgrade","text":"zos does not support migrations, hence all the initial configuration should be performed with Nevermined Contract Tools . Contract constructors are ignored so the initial setup of the contract should be made in a initialize function that will be executed only once after the initial deployment.","title":"Deploy &amp; Upgrade"},{"location":"Upgrades/#1-configuration","text":"Nevermined Contract Tools checks the contracts.json in order to detect the current contracts that are going to be deployed: [ \"ConditionStoreManager\" , \"TemplateStoreManager\" , \"AgreementStoreManager\" , \"SignCondition\" , \"HashLockCondition\" , \"LockRewardCondition\" , \"NFTHolderCondition\" , \"AccessCondition\" , \"EscrowReward\" , \"EscrowAccessSecretStoreTemplate\" , \"NFTAccessTemplate\" , \"DIDRegistry\" ] Moreover for each network, Nevermined Contract Tools needs to detect the roles and their addresses from a pre-defined wallets config file. The following configuration should be an example for wallets-<NETWORK_NAME>.json : [ { \"name\" : \"upgrader\" , \"address\" : \"0x24eb26d4042a2ab576e7e39b87c3f33f276aef92\" }, { \"name\" : \"owner\" , \"address\" : \"0xd02d68c62401472ce35ba3c7e505deae62db2b8b\" } ]","title":"1. Configuration"},{"location":"Upgrades/#2-preparation","text":"The following commands clean, install dependencies and compile the contracts: $ yarn clean #to clean the work dir $ yarn #install dependencies $ yarn compile #to compile the contracts","title":"2. Preparation"},{"location":"Upgrades/#3-deploy-upgrade","text":"The following steps shows how to perform contracts deployment and upgrade on Rinkeby and Kovan networks.","title":"3. Deploy &amp; Upgrade"},{"location":"Upgrades/#nile","text":"Copy the wallet file for rinkeby cp wallets_rinkeby.json wallets.json run export MNEMONIC=<your staging mnemonic> . You will find them in the password manager.","title":"Nile"},{"location":"Upgrades/#deploy-the-whole-application","text":"To deploy all contracts run yarn deploy:rinkeby","title":"Deploy the whole application"},{"location":"Upgrades/#deploy-a-single-contracts","text":"To deploy a single contract you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:rinkeby -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser .","title":"Deploy a single contracts"},{"location":"Upgrades/#upgrade-the-whole-application","text":"To upgrade all contracts run yarn upgrade:rinkeby","title":"Upgrade the whole application"},{"location":"Upgrades/#upgrade-a-single-contract","text":"To upgrade a single contract run yarn upgrade:rinkeby -- NeverminedToken . For upgrading the NeverminedToken contract.","title":"Upgrade a single contract"},{"location":"Upgrades/#persist-artifacts","text":"Commit all changes in artifacts/*.rinkeby.json","title":"Persist artifacts"},{"location":"Upgrades/#kovan","text":"Copy the wallet file for kovan > cp wallets_kovan.json wallets.json run export MNEMONIC=<your kovan mnemonic> . You will find them in the password manager. run export INFURA_TOKEN=<your infura token> . You will get it from infura .","title":"Kovan"},{"location":"Upgrades/#deploy-the-whole-application_1","text":"To deploy all the contracts run yarn deploy:kovan","title":"Deploy the whole application"},{"location":"Upgrades/#deploy-a-single-contracts_1","text":"To deploy a single contracts you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:kovan -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser .","title":"Deploy a single contracts"},{"location":"Upgrades/#upgrade-the-whole-application_1","text":"To upgrade all contracts run yarn upgrade:kovan","title":"Upgrade the whole application"},{"location":"Upgrades/#upgrade-a-single-contract_1","text":"To upgrade a single contract run yarn upgrade:kovan -- NeverminedToken . For upgrading the NeverminedToken contract.","title":"Upgrade a single contract"},{"location":"Upgrades/#persist-artifacts_1","text":"Commit all changes in artifacts/*.kovan.json","title":"Persist artifacts"},{"location":"Upgrades/#4-approve-upgrades","text":"All upgrades of the contracts have to be approved by the upgrader wallet configured in the wallets.json file. go to https://wallet.gnosis.pm Load upgrader wallet Select an Ethereum Account that is an owner of the multi sig wallet, but not the one who issued the upgrade request. This can be done in the following ways: Connect to a local Blockchain node that holds the private key. Connect to MetaMask and select the owner account from the multi sig wallet. Connect a hardware wallet like ledger or trezor. Select the transaction you want to confirm (the upgrade script will tell you which transactions have to be approved in which wallets) Click Confirm","title":"4. Approve Upgrade(s)"},{"location":"Upgrades/#5-audit-contracts","text":"To check or document that all transactions have been approved in the multi sig wallet you can run yarn audit:rinkeby to get a list of all the current transactions and their current status. Wallet: 0x24EB26D4042a2AB576E7E39b87c3f33f276AeF92 Transaction ID: 64 Destination: 0xfA16d26e9F4fffC6e40963B281a0bB08C31ed40C Contract: EscrowAccessSecretStoreTemplate Data is `upgradeTo` call: true Confirmed from: 0x7A13E1aD23546c9b804aDFd13e9AcB184EfCAF58 Executed: false","title":"5. Audit Contracts"},{"location":"Upgrades/#6-documentation","text":"Update the addresses in the README.md run node ./scripts/contracts/get-addresses.js <network name> It will output the current proxy addresses in the README friendly format. | AccessCondition | v0.9.0 | 0x45DE141F8Efc355F1451a102FB6225F1EDd2921d | | AgreementStoreManager | v0.9.0 | 0x62f84700b1A0ea6Bfb505aDC3c0286B7944D247C | | ConditionStoreManager | v0.9.0 | 0x39b0AA775496C5ebf26f3B81C9ed1843f09eE466 | | DIDRegistry | v0.9.0 | 0x4A0f7F763B1A7937aED21D63b2A78adc89c5Db23 | | DIDRegistryLibrary | v0.9.0 | 0x3B3504908Db36f5D5f07CD420ee2BBBbDfB674cF | | Dispenser | v0.9.0 | 0x865396b7ddc58C693db7FCAD1168E3BD95Fe3368 | .... Copy this to the README.md","title":"6. Documentation"},{"location":"contracts/Common/","text":"Functions \u00b6 getCurrentBlockNumber \u00b6 function getCurrentBlockNumber ( ) external returns ( uint256 ) getCurrentBlockNumber get block number Return Values: \u00b6 Name Type Description the current block number ### isContract function isContract ( ) public returns ( bool ) isContract detect whether the address is is a contract address or externally owned account Return Values: \u00b6 Name Type Description true address if it is a contract address ### provenanceSignatureIsCorrect function provenanceSignatureIsCorrect ( address _agentId , bytes32 _hash , bytes _signature ) public returns ( bool ) Parameters: \u00b6 Name Type Description _agentId address The address of the agent _hash bytes32 bytes32 message, the hash is the signed message. What is recovered is the signer address. _signature bytes Signatures provided by the agent Return Values: \u00b6 Name Type Description true address if the signature correspond to the agent address ### calculateTotalAmount function calculateTotalAmount ( ) public returns ( uint256 ) Sum the total amount given an uint array Return Values: \u00b6 Name Type Description the uint256[] total amount","title":"Common"},{"location":"contracts/Common/#functions","text":"","title":"Functions"},{"location":"contracts/Common/#getcurrentblocknumber","text":"function getCurrentBlockNumber ( ) external returns ( uint256 ) getCurrentBlockNumber get block number","title":"getCurrentBlockNumber"},{"location":"contracts/Common/#return-values","text":"Name Type Description the current block number ### isContract function isContract ( ) public returns ( bool ) isContract detect whether the address is is a contract address or externally owned account","title":"Return Values:"},{"location":"contracts/Common/#return-values_1","text":"Name Type Description true address if it is a contract address ### provenanceSignatureIsCorrect function provenanceSignatureIsCorrect ( address _agentId , bytes32 _hash , bytes _signature ) public returns ( bool )","title":"Return Values:"},{"location":"contracts/Common/#parameters","text":"Name Type Description _agentId address The address of the agent _hash bytes32 bytes32 message, the hash is the signed message. What is recovered is the signer address. _signature bytes Signatures provided by the agent","title":"Parameters:"},{"location":"contracts/Common/#return-values_2","text":"Name Type Description true address if the signature correspond to the agent address ### calculateTotalAmount function calculateTotalAmount ( ) public returns ( uint256 ) Sum the total amount given an uint array","title":"Return Values:"},{"location":"contracts/Common/#return-values_3","text":"Name Type Description the uint256[] total amount","title":"Return Values:"},{"location":"contracts/Dispenser/","text":"Functions \u00b6 initialize \u00b6 function initialize ( address _tokenAddress , address _owner ) external Dispenser Initializer Parameters: \u00b6 Name Type Description _tokenAddress address The deployed contract address of an ERC20 _owner address The owner of the Dispenser Runs only on initial contract creation. requestTokens \u00b6 function requestTokens ( uint256 amount ) external returns ( bool tokensTransferred ) user can request some tokens for testing Parameters: \u00b6 Name Type Description amount uint256 the amount of tokens to be requested Return Values: \u00b6 Name Type Description tokensTransferred uint256 Boolean indication of tokens are requested ### setMinPeriod function setMinPeriod ( uint256 period ) external the Owner can set the min period for token requests Parameters: \u00b6 Name Type Description period uint256 the min amount of time before next request setMaxAmount \u00b6 function setMaxAmount ( uint256 amount ) external the Owner can set the max amount for token requests Parameters: \u00b6 Name Type Description amount uint256 the max amount of tokens that can be requested setMaxMintAmount \u00b6 function setMaxMintAmount ( uint256 amount ) external the Owner can set the max amount for token requests Parameters: \u00b6 Name Type Description amount uint256 the max amount of tokens that can be requested Events \u00b6 RequestFrequencyExceeded \u00b6 event RequestFrequencyExceeded ( ) RequestLimitExceeded \u00b6 event RequestLimitExceeded ( )","title":"Dispenser"},{"location":"contracts/Dispenser/#functions","text":"","title":"Functions"},{"location":"contracts/Dispenser/#initialize","text":"function initialize ( address _tokenAddress , address _owner ) external Dispenser Initializer","title":"initialize"},{"location":"contracts/Dispenser/#parameters","text":"Name Type Description _tokenAddress address The deployed contract address of an ERC20 _owner address The owner of the Dispenser Runs only on initial contract creation.","title":"Parameters:"},{"location":"contracts/Dispenser/#requesttokens","text":"function requestTokens ( uint256 amount ) external returns ( bool tokensTransferred ) user can request some tokens for testing","title":"requestTokens"},{"location":"contracts/Dispenser/#parameters_1","text":"Name Type Description amount uint256 the amount of tokens to be requested","title":"Parameters:"},{"location":"contracts/Dispenser/#return-values","text":"Name Type Description tokensTransferred uint256 Boolean indication of tokens are requested ### setMinPeriod function setMinPeriod ( uint256 period ) external the Owner can set the min period for token requests","title":"Return Values:"},{"location":"contracts/Dispenser/#parameters_2","text":"Name Type Description period uint256 the min amount of time before next request","title":"Parameters:"},{"location":"contracts/Dispenser/#setmaxamount","text":"function setMaxAmount ( uint256 amount ) external the Owner can set the max amount for token requests","title":"setMaxAmount"},{"location":"contracts/Dispenser/#parameters_3","text":"Name Type Description amount uint256 the max amount of tokens that can be requested","title":"Parameters:"},{"location":"contracts/Dispenser/#setmaxmintamount","text":"function setMaxMintAmount ( uint256 amount ) external the Owner can set the max amount for token requests","title":"setMaxMintAmount"},{"location":"contracts/Dispenser/#parameters_4","text":"Name Type Description amount uint256 the max amount of tokens that can be requested","title":"Parameters:"},{"location":"contracts/Dispenser/#events","text":"","title":"Events"},{"location":"contracts/Dispenser/#requestfrequencyexceeded","text":"event RequestFrequencyExceeded ( )","title":"RequestFrequencyExceeded"},{"location":"contracts/Dispenser/#requestlimitexceeded","text":"event RequestLimitExceeded ( )","title":"RequestLimitExceeded"},{"location":"contracts/HashLists/","text":"Hash lists contract is a sample list contract in which uses HashListLibrary.sol in order to store, retrieve, remove, and update bytes32 values in hash lists. This is a reference implementation for IList interface. It is used for whitelisting condition. Any entity can have its own implementation of the interface in which could be used for the same condition. Functions \u00b6 initialize \u00b6 function initialize ( address _owner ) public HashLists Initializer Parameters: \u00b6 Name Type Description _owner address The owner of the hash list Runs only upon contract creation. hash \u00b6 function hash ( address account ) public returns ( bytes32 ) hash ethereum accounts Parameters: \u00b6 Name Type Description account address Ethereum address Return Values: \u00b6 Name Type Description bytes32 address hash of the account ### add function add ( bytes32 [] values ) external returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays Parameters: \u00b6 Name Type Description values bytes32[] is an array of elements value Return Values: \u00b6 Name Type Description true bytes32[] if values are added successfully ### add function add ( bytes32 value ) external returns ( bool ) add indexes an element then adds it to a list Parameters: \u00b6 Name Type Description value bytes32 is a bytes32 value Return Values: \u00b6 Name Type Description true bytes32 if value is added successfully ### update function update ( bytes32 oldValue , bytes32 newValue ) external returns ( bool ) update the value with a new value and maintain indices Parameters: \u00b6 Name Type Description oldValue bytes32 is an element value in a list newValue bytes32 new value Return Values: \u00b6 Name Type Description true bytes32 if value is updated successfully ### index function index ( uint256 from , uint256 to ) external returns ( bool ) index is used to map each element value to its index on the list Parameters: \u00b6 Name Type Description from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Return Values: \u00b6 Name Type Description true uint256 if the sub list is indexed ### has function has ( bytes32 id , bytes32 value ) external returns ( bool ) has checks whether a value is exist Parameters: \u00b6 Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Return Values: \u00b6 Name Type Description true bytes32 if the value exists ### has function has ( bytes32 value ) external returns ( bool ) has checks whether a value is exist Parameters: \u00b6 Name Type Description value bytes32 is element value in list Return Values: \u00b6 Name Type Description true bytes32 if the value exists ### remove function remove ( bytes32 value ) external returns ( bool ) remove value from a list, updates indices, and list size Parameters: \u00b6 Name Type Description value bytes32 is an element value in a list Return Values: \u00b6 Name Type Description true bytes32 if value is removed successfully ### get function get ( bytes32 id , uint256 _index ) external returns ( bytes32 ) has value by index Parameters: \u00b6 Name Type Description id bytes32 the list identifier (the hash of list owner's address) _index uint256 is where is value is stored in the list Return Values: \u00b6 Name Type Description the bytes32 value if exists ### size function size ( bytes32 id ) external returns ( uint256 ) size gets the list size Parameters: \u00b6 Name Type Description id bytes32 the list identifier (the hash of list owner's address) Return Values: \u00b6 Name Type Description total bytes32 length of the list ### all function all ( bytes32 id ) external returns ( bytes32 []) all returns all list elements Parameters: \u00b6 Name Type Description id bytes32 the list identifier (the hash of list owner's address) Return Values: \u00b6 Name Type Description all bytes32 list elements ### indexOf function indexOf ( bytes32 id , bytes32 value ) external returns ( uint256 ) indexOf gets the index of a value in a list Parameters: \u00b6 Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Return Values: \u00b6 Name Type Description value bytes32 index in list ### ownedBy function ownedBy ( bytes32 id ) external returns ( address ) ownedBy gets the list owner Parameters: \u00b6 Name Type Description id bytes32 the list identifier (the hash of list owner's address) Return Values: \u00b6 Name Type Description list bytes32 owner ### isIndexed function isIndexed ( bytes32 id ) external returns ( bool ) isIndexed checks if the list is indexed Parameters: \u00b6 Name Type Description id bytes32 the list identifier (the hash of list owner's address) Return Values: \u00b6 Name Type Description true bytes32 if the list is indexed","title":"HashLists"},{"location":"contracts/HashLists/#functions","text":"","title":"Functions"},{"location":"contracts/HashLists/#initialize","text":"function initialize ( address _owner ) public HashLists Initializer","title":"initialize"},{"location":"contracts/HashLists/#parameters","text":"Name Type Description _owner address The owner of the hash list Runs only upon contract creation.","title":"Parameters:"},{"location":"contracts/HashLists/#hash","text":"function hash ( address account ) public returns ( bytes32 ) hash ethereum accounts","title":"hash"},{"location":"contracts/HashLists/#parameters_1","text":"Name Type Description account address Ethereum address","title":"Parameters:"},{"location":"contracts/HashLists/#return-values","text":"Name Type Description bytes32 address hash of the account ### add function add ( bytes32 [] values ) external returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays","title":"Return Values:"},{"location":"contracts/HashLists/#parameters_2","text":"Name Type Description values bytes32[] is an array of elements value","title":"Parameters:"},{"location":"contracts/HashLists/#return-values_1","text":"Name Type Description true bytes32[] if values are added successfully ### add function add ( bytes32 value ) external returns ( bool ) add indexes an element then adds it to a list","title":"Return Values:"},{"location":"contracts/HashLists/#parameters_3","text":"Name Type Description value bytes32 is a bytes32 value","title":"Parameters:"},{"location":"contracts/HashLists/#return-values_2","text":"Name Type Description true bytes32 if value is added successfully ### update function update ( bytes32 oldValue , bytes32 newValue ) external returns ( bool ) update the value with a new value and maintain indices","title":"Return Values:"},{"location":"contracts/HashLists/#parameters_4","text":"Name Type Description oldValue bytes32 is an element value in a list newValue bytes32 new value","title":"Parameters:"},{"location":"contracts/HashLists/#return-values_3","text":"Name Type Description true bytes32 if value is updated successfully ### index function index ( uint256 from , uint256 to ) external returns ( bool ) index is used to map each element value to its index on the list","title":"Return Values:"},{"location":"contracts/HashLists/#parameters_5","text":"Name Type Description from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing","title":"Parameters:"},{"location":"contracts/HashLists/#return-values_4","text":"Name Type Description true uint256 if the sub list is indexed ### has function has ( bytes32 id , bytes32 value ) external returns ( bool ) has checks whether a value is exist","title":"Return Values:"},{"location":"contracts/HashLists/#parameters_6","text":"Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list","title":"Parameters:"},{"location":"contracts/HashLists/#return-values_5","text":"Name Type Description true bytes32 if the value exists ### has function has ( bytes32 value ) external returns ( bool ) has checks whether a value is exist","title":"Return Values:"},{"location":"contracts/HashLists/#parameters_7","text":"Name Type Description value bytes32 is element value in list","title":"Parameters:"},{"location":"contracts/HashLists/#return-values_6","text":"Name Type Description true bytes32 if the value exists ### remove function remove ( bytes32 value ) external returns ( bool ) remove value from a list, updates indices, and list size","title":"Return Values:"},{"location":"contracts/HashLists/#parameters_8","text":"Name Type Description value bytes32 is an element value in a list","title":"Parameters:"},{"location":"contracts/HashLists/#return-values_7","text":"Name Type Description true bytes32 if value is removed successfully ### get function get ( bytes32 id , uint256 _index ) external returns ( bytes32 ) has value by index","title":"Return Values:"},{"location":"contracts/HashLists/#parameters_9","text":"Name Type Description id bytes32 the list identifier (the hash of list owner's address) _index uint256 is where is value is stored in the list","title":"Parameters:"},{"location":"contracts/HashLists/#return-values_8","text":"Name Type Description the bytes32 value if exists ### size function size ( bytes32 id ) external returns ( uint256 ) size gets the list size","title":"Return Values:"},{"location":"contracts/HashLists/#parameters_10","text":"Name Type Description id bytes32 the list identifier (the hash of list owner's address)","title":"Parameters:"},{"location":"contracts/HashLists/#return-values_9","text":"Name Type Description total bytes32 length of the list ### all function all ( bytes32 id ) external returns ( bytes32 []) all returns all list elements","title":"Return Values:"},{"location":"contracts/HashLists/#parameters_11","text":"Name Type Description id bytes32 the list identifier (the hash of list owner's address)","title":"Parameters:"},{"location":"contracts/HashLists/#return-values_10","text":"Name Type Description all bytes32 list elements ### indexOf function indexOf ( bytes32 id , bytes32 value ) external returns ( uint256 ) indexOf gets the index of a value in a list","title":"Return Values:"},{"location":"contracts/HashLists/#parameters_12","text":"Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list","title":"Parameters:"},{"location":"contracts/HashLists/#return-values_11","text":"Name Type Description value bytes32 index in list ### ownedBy function ownedBy ( bytes32 id ) external returns ( address ) ownedBy gets the list owner","title":"Return Values:"},{"location":"contracts/HashLists/#parameters_13","text":"Name Type Description id bytes32 the list identifier (the hash of list owner's address)","title":"Parameters:"},{"location":"contracts/HashLists/#return-values_12","text":"Name Type Description list bytes32 owner ### isIndexed function isIndexed ( bytes32 id ) external returns ( bool ) isIndexed checks if the list is indexed","title":"Return Values:"},{"location":"contracts/HashLists/#parameters_14","text":"Name Type Description id bytes32 the list identifier (the hash of list owner's address)","title":"Parameters:"},{"location":"contracts/HashLists/#return-values_13","text":"Name Type Description true bytes32 if the list is indexed","title":"Return Values:"},{"location":"contracts/NeverminedToken/","text":"Implementation of a Test Token. Test Token is an ERC20 token only for testing purposes Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address payable _initialMinter ) public NeverminedToken Initializer Runs only on initial contract creation. Parameters: \u00b6 Name Type Description _owner address refers to the owner of the contract _initialMinter address payable is the first token minter added _beforeTokenTransfer \u00b6 function _beforeTokenTransfer ( ) internal See {ERC20-_beforeTokenTransfer}. Requirements: minted tokens must not cause the total supply to go over the cap. mint \u00b6 function mint ( ) external returns ( bool ) Creates amount tokens and assigns them to account , increasing the total supply. Emits a {Transfer} event with from set to the zero address. Requirements: to cannot be the zero address.","title":"NeverminedToken"},{"location":"contracts/NeverminedToken/#functions","text":"","title":"Functions"},{"location":"contracts/NeverminedToken/#initialize","text":"function initialize ( address _owner , address payable _initialMinter ) public NeverminedToken Initializer Runs only on initial contract creation.","title":"initialize"},{"location":"contracts/NeverminedToken/#parameters","text":"Name Type Description _owner address refers to the owner of the contract _initialMinter address payable is the first token minter added","title":"Parameters:"},{"location":"contracts/NeverminedToken/#_beforetokentransfer","text":"function _beforeTokenTransfer ( ) internal See {ERC20-_beforeTokenTransfer}. Requirements: minted tokens must not cause the total supply to go over the cap.","title":"_beforeTokenTransfer"},{"location":"contracts/NeverminedToken/#mint","text":"function mint ( ) external returns ( bool ) Creates amount tokens and assigns them to account , increasing the total supply. Emits a {Transfer} event with from set to the zero address. Requirements: to cannot be the zero address.","title":"mint"},{"location":"contracts/PlonkVerifier/","text":"Functions \u00b6 verifyProof \u00b6 function verifyProof ( ) public returns ( bool )","title":"PlonkVerifier"},{"location":"contracts/PlonkVerifier/#functions","text":"","title":"Functions"},{"location":"contracts/PlonkVerifier/#verifyproof","text":"function verifyProof ( ) public returns ( bool )","title":"verifyProof"},{"location":"contracts/agreements/AgreementStoreLibrary/","text":"Implementation of the Agreement Store Library. For more information: https://github.com/oceanprotocol/OEPs/issues/125 TODO: update the OEP link The agreement store library holds the business logic in which manages the life cycle of SEA agreement, each agreement is linked to the DID of an asset, template, and condition IDs. Functions \u00b6 create \u00b6 function create ( struct AgreementStoreLibrary . AgreementList _self , bytes32 _id , bytes32 _did , address _templateId , bytes32 [] _conditionIds ) internal returns ( uint256 size ) create new agreement checks whether the agreement Id exists, creates new agreement instance, including the template, conditions and DID. Parameters: \u00b6 Name Type Description _self struct AgreementStoreLibrary.AgreementList is AgreementList storage pointer _id bytes32 agreement identifier _did bytes32 asset decentralized identifier _templateId address template identifier _conditionIds bytes32[] array of condition identifiers Return Values: \u00b6 Name Type Description size struct AgreementStoreLibrary.AgreementList which is the index of the created agreement","title":"AgreementStoreLibrary"},{"location":"contracts/agreements/AgreementStoreLibrary/#functions","text":"","title":"Functions"},{"location":"contracts/agreements/AgreementStoreLibrary/#create","text":"function create ( struct AgreementStoreLibrary . AgreementList _self , bytes32 _id , bytes32 _did , address _templateId , bytes32 [] _conditionIds ) internal returns ( uint256 size ) create new agreement checks whether the agreement Id exists, creates new agreement instance, including the template, conditions and DID.","title":"create"},{"location":"contracts/agreements/AgreementStoreLibrary/#parameters","text":"Name Type Description _self struct AgreementStoreLibrary.AgreementList is AgreementList storage pointer _id bytes32 agreement identifier _did bytes32 asset decentralized identifier _templateId address template identifier _conditionIds bytes32[] array of condition identifiers","title":"Parameters:"},{"location":"contracts/agreements/AgreementStoreLibrary/#return-values","text":"Name Type Description size struct AgreementStoreLibrary.AgreementList which is the index of the created agreement","title":"Return Values:"},{"location":"contracts/agreements/AgreementStoreManager/","text":"Implementation of the Agreement Store. The agreement store generates conditions for an agreement template. Agreement templates must to be approved in the Template Store Each agreement is linked to the DID of an asset. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _templateStoreManagerAddress , address _didRegistryAddress ) public initialize AgreementStoreManager Initializer Initializes Ownable. Only on contract creation. Parameters: \u00b6 Name Type Description _owner address refers to the owner of the contract _conditionStoreManagerAddress address is the address of the connected condition store _templateStoreManagerAddress address is the address of the connected template store _didRegistryAddress address is the address of the connected DID Registry createAgreement \u00b6 function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public returns ( uint256 size ) Create a new agreement and associate the agreement created to the address originating the transaction. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function. Parameters: \u00b6 Name Type Description _id bytes32 is the ID of the new agreement. Must be unique. _did bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. _conditionTypes address[] is a list of addresses that point to Condition contracts. _conditionIds bytes32[] is a list of bytes32 content-addressed Condition IDs _timeLocks uint256[] is a list of uint time lock values associated to each Condition _timeOuts uint256[] is a list of uint time out values associated to each Condition Return Values: \u00b6 Name Type Description size bytes32 the size of the agreement list after the create action. ### createAgreement function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _creator ) public returns ( uint256 size ) Create a new agreement. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function. Parameters: \u00b6 Name Type Description _id bytes32 is the ID of the new agreement. Must be unique. _did bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. _conditionTypes address[] is a list of addresses that point to Condition contracts. _conditionIds bytes32[] is a list of bytes32 content-addressed Condition IDs _timeLocks uint256[] is a list of uint time lock values associated to each Condition _timeOuts uint256[] is a list of uint time out values associated to each Condition _creator address address of the account associated as agreement and conditions creator Return Values: \u00b6 Name Type Description size bytes32 the size of the agreement list after the create action. ### getAgreement function getAgreement ( bytes32 _id ) external returns ( bytes32 did , address didOwner , address templateId , bytes32 [] conditionIds , address lastUpdatedBy , uint256 blockNumberUpdated ) Get agreement with _id. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function. Parameters: \u00b6 Name Type Description _id bytes32 is the ID of the agreement. getAgreementDIDOwner \u00b6 function getAgreementDIDOwner ( bytes32 _id ) external returns ( address didOwner ) get the DID owner for this agreement with _id. Parameters: \u00b6 Name Type Description _id bytes32 is the ID of the agreement. Return Values: \u00b6 Name Type Description didOwner bytes32 the DID owner associated with agreement.did from the DID registry. ### isAgreementDIDOwner function isAgreementDIDOwner ( bytes32 _id , address _owner ) external returns ( bool ) check the DID owner for this agreement with _id. Parameters: \u00b6 Name Type Description _id bytes32 is the ID of the agreement. _owner address is the DID owner Return Values: \u00b6 Name Type Description the bytes32 DID owner associated with agreement.did from the DID registry. ### isAgreementDIDProvider function isAgreementDIDProvider ( bytes32 _id , address _provider ) external returns ( bool ) isAgreementDIDProvider for a given agreement Id and address check whether a DID provider is associated with this agreement Parameters: \u00b6 Name Type Description _id bytes32 is the ID of the agreement _provider address is the DID provider Return Values: \u00b6 Name Type Description true bytes32 if a DID provider is associated with the agreement ID ### getAgreementListSize function getAgreementListSize ( ) public returns ( uint256 size ) Return Values: \u00b6 Name Type Description size the length of the agreement list. ### getAgreementIdsForDID function getAgreementIdsForDID ( bytes32 _did ) public returns ( bytes32 []) Parameters: \u00b6 Name Type Description _did bytes32 is the bytes32 DID of the asset. Return Values: \u00b6 Name Type Description the bytes32 agreement IDs for a given DID ### getAgreementIdsForTemplateId function getAgreementIdsForTemplateId ( address _templateId ) public returns ( bytes32 []) Parameters: \u00b6 Name Type Description _templateId address is the address of the agreement template. Return Values: \u00b6 Name Type Description the address agreement IDs for a given DID ### getDIDRegistryAddress function getDIDRegistryAddress ( ) public returns ( address ) getDIDRegistryAddress utility function used by other contracts or any EOA. Return Values: \u00b6 Name Type Description the DIDRegistry address","title":"AgreementStoreManager"},{"location":"contracts/agreements/AgreementStoreManager/#functions","text":"","title":"Functions"},{"location":"contracts/agreements/AgreementStoreManager/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _templateStoreManagerAddress , address _didRegistryAddress ) public initialize AgreementStoreManager Initializer Initializes Ownable. Only on contract creation.","title":"initialize"},{"location":"contracts/agreements/AgreementStoreManager/#parameters","text":"Name Type Description _owner address refers to the owner of the contract _conditionStoreManagerAddress address is the address of the connected condition store _templateStoreManagerAddress address is the address of the connected template store _didRegistryAddress address is the address of the connected DID Registry","title":"Parameters:"},{"location":"contracts/agreements/AgreementStoreManager/#createagreement","text":"function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public returns ( uint256 size ) Create a new agreement and associate the agreement created to the address originating the transaction. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function.","title":"createAgreement"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_1","text":"Name Type Description _id bytes32 is the ID of the new agreement. Must be unique. _did bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. _conditionTypes address[] is a list of addresses that point to Condition contracts. _conditionIds bytes32[] is a list of bytes32 content-addressed Condition IDs _timeLocks uint256[] is a list of uint time lock values associated to each Condition _timeOuts uint256[] is a list of uint time out values associated to each Condition","title":"Parameters:"},{"location":"contracts/agreements/AgreementStoreManager/#return-values","text":"Name Type Description size bytes32 the size of the agreement list after the create action. ### createAgreement function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _creator ) public returns ( uint256 size ) Create a new agreement. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function.","title":"Return Values:"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_2","text":"Name Type Description _id bytes32 is the ID of the new agreement. Must be unique. _did bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. _conditionTypes address[] is a list of addresses that point to Condition contracts. _conditionIds bytes32[] is a list of bytes32 content-addressed Condition IDs _timeLocks uint256[] is a list of uint time lock values associated to each Condition _timeOuts uint256[] is a list of uint time out values associated to each Condition _creator address address of the account associated as agreement and conditions creator","title":"Parameters:"},{"location":"contracts/agreements/AgreementStoreManager/#return-values_1","text":"Name Type Description size bytes32 the size of the agreement list after the create action. ### getAgreement function getAgreement ( bytes32 _id ) external returns ( bytes32 did , address didOwner , address templateId , bytes32 [] conditionIds , address lastUpdatedBy , uint256 blockNumberUpdated ) Get agreement with _id. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function.","title":"Return Values:"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_3","text":"Name Type Description _id bytes32 is the ID of the agreement.","title":"Parameters:"},{"location":"contracts/agreements/AgreementStoreManager/#getagreementdidowner","text":"function getAgreementDIDOwner ( bytes32 _id ) external returns ( address didOwner ) get the DID owner for this agreement with _id.","title":"getAgreementDIDOwner"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_4","text":"Name Type Description _id bytes32 is the ID of the agreement.","title":"Parameters:"},{"location":"contracts/agreements/AgreementStoreManager/#return-values_2","text":"Name Type Description didOwner bytes32 the DID owner associated with agreement.did from the DID registry. ### isAgreementDIDOwner function isAgreementDIDOwner ( bytes32 _id , address _owner ) external returns ( bool ) check the DID owner for this agreement with _id.","title":"Return Values:"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_5","text":"Name Type Description _id bytes32 is the ID of the agreement. _owner address is the DID owner","title":"Parameters:"},{"location":"contracts/agreements/AgreementStoreManager/#return-values_3","text":"Name Type Description the bytes32 DID owner associated with agreement.did from the DID registry. ### isAgreementDIDProvider function isAgreementDIDProvider ( bytes32 _id , address _provider ) external returns ( bool ) isAgreementDIDProvider for a given agreement Id and address check whether a DID provider is associated with this agreement","title":"Return Values:"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_6","text":"Name Type Description _id bytes32 is the ID of the agreement _provider address is the DID provider","title":"Parameters:"},{"location":"contracts/agreements/AgreementStoreManager/#return-values_4","text":"Name Type Description true bytes32 if a DID provider is associated with the agreement ID ### getAgreementListSize function getAgreementListSize ( ) public returns ( uint256 size )","title":"Return Values:"},{"location":"contracts/agreements/AgreementStoreManager/#return-values_5","text":"Name Type Description size the length of the agreement list. ### getAgreementIdsForDID function getAgreementIdsForDID ( bytes32 _did ) public returns ( bytes32 [])","title":"Return Values:"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_7","text":"Name Type Description _did bytes32 is the bytes32 DID of the asset.","title":"Parameters:"},{"location":"contracts/agreements/AgreementStoreManager/#return-values_6","text":"Name Type Description the bytes32 agreement IDs for a given DID ### getAgreementIdsForTemplateId function getAgreementIdsForTemplateId ( address _templateId ) public returns ( bytes32 [])","title":"Return Values:"},{"location":"contracts/agreements/AgreementStoreManager/#parameters_8","text":"Name Type Description _templateId address is the address of the agreement template.","title":"Parameters:"},{"location":"contracts/agreements/AgreementStoreManager/#return-values_7","text":"Name Type Description the address agreement IDs for a given DID ### getDIDRegistryAddress function getDIDRegistryAddress ( ) public returns ( address ) getDIDRegistryAddress utility function used by other contracts or any EOA.","title":"Return Values:"},{"location":"contracts/agreements/AgreementStoreManager/#return-values_8","text":"Name Type Description the DIDRegistry address","title":"Return Values:"},{"location":"contracts/conditions/AccessCondition/","text":"Implementation of the Access Condition Access Secret Store Condition is special condition where a client or Parity secret store can encrypt/decrypt documents based on the on-chain granted permissions. For a given DID document, and agreement ID, the owner/provider of the DID will fulfill the condition. Consequently secret store will check whether the permission is granted for the consumer in order to encrypt/decrypt the document. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address hashValues \u00b6 function hashValues ( bytes32 _documentId , address _grantee ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill access secret store condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ### grantPermission function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider Parameters: \u00b6 Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys renouncePermission \u00b6 function renouncePermission ( address _grantee , bytes32 _documentId ) public renouncePermission is called only by DID owner or provider Parameters: \u00b6 Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys checkPermissions \u00b6 function checkPermissions ( address _documentId , bytes32 _grantee ) external returns ( bool permissionGranted ) checkPermissions is called by Parity secret store Parameters: \u00b6 Name Type Description _documentId address refers to the DID in which secret store will issue the decryption keys _grantee bytes32 is the address of the granted user or the DID provider Return Values: \u00b6 Name Type Description permissionGranted address true if the access was granted ## Events ### Fulfilled event Fulfilled ( )","title":"AccessCondition"},{"location":"contracts/conditions/AccessCondition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/AccessCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"contracts/conditions/AccessCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address","title":"Parameters:"},{"location":"contracts/conditions/AccessCondition/#hashvalues","text":"function hashValues ( bytes32 _documentId , address _grantee ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/AccessCondition/#parameters_1","text":"Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider","title":"Parameters:"},{"location":"contracts/conditions/AccessCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill access secret store condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition","title":"Return Values:"},{"location":"contracts/conditions/AccessCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider","title":"Parameters:"},{"location":"contracts/conditions/AccessCondition/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ### grantPermission function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider","title":"Return Values:"},{"location":"contracts/conditions/AccessCondition/#parameters_3","text":"Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys","title":"Parameters:"},{"location":"contracts/conditions/AccessCondition/#renouncepermission","text":"function renouncePermission ( address _grantee , bytes32 _documentId ) public renouncePermission is called only by DID owner or provider","title":"renouncePermission"},{"location":"contracts/conditions/AccessCondition/#parameters_4","text":"Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys","title":"Parameters:"},{"location":"contracts/conditions/AccessCondition/#checkpermissions","text":"function checkPermissions ( address _documentId , bytes32 _grantee ) external returns ( bool permissionGranted ) checkPermissions is called by Parity secret store","title":"checkPermissions"},{"location":"contracts/conditions/AccessCondition/#parameters_5","text":"Name Type Description _documentId address refers to the DID in which secret store will issue the decryption keys _grantee bytes32 is the address of the granted user or the DID provider","title":"Parameters:"},{"location":"contracts/conditions/AccessCondition/#return-values_2","text":"Name Type Description permissionGranted address true if the access was granted ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"contracts/conditions/AccessProofCondition/","text":"Implementation of the Access Condition with transfer proof. The idea is that the hash of the decryption key is known before hand, and the key matching this hash is passed from data provider to the buyer using this smart contract. Using ZK proof the key is kept hidden from outsiders. For the protocol to work, both the provider and buyer need to have public keys in the babyjub curve. To initiate the deal, buyer will pass the key hash and the public keys of participants. The provider needs to pass the cipher text encrypted using MIMC (symmetric encryption). The secret key for MIMC is computed using ECDH (requires one public key and one secret key for the curve). The hash function that is used is Poseidon. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress , address _disputeManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address _disputeManagerAddress address dispute manager address hashValues \u00b6 function hashValues ( uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _origHash uint256 is the hash of the key _buyer uint256[2] buyer public key _provider uint256[2] provider public key Return Values: \u00b6 Name Type Description bytes32 uint256 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider , uint256 [ 2 ] _cipher , bytes _proof ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill key transfer The key with hash _origHash is transferred to the _buyer from _provider. Parameters: \u00b6 Name Type Description _agreementId bytes32 associated agreement _origHash uint256 is the hash of data to access _buyer uint256[2] buyer public key _provider uint256[2] provider public key _cipher uint256[2] encrypted version of the key _proof bytes SNARK proof that the cipher text can be decrypted by buyer to give the key with hash _origHash Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"AccessProofCondition"},{"location":"contracts/conditions/AccessProofCondition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/AccessProofCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress , address _disputeManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"contracts/conditions/AccessProofCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address _disputeManagerAddress address dispute manager address","title":"Parameters:"},{"location":"contracts/conditions/AccessProofCondition/#hashvalues","text":"function hashValues ( uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/AccessProofCondition/#parameters_1","text":"Name Type Description _origHash uint256 is the hash of the key _buyer uint256[2] buyer public key _provider uint256[2] provider public key","title":"Parameters:"},{"location":"contracts/conditions/AccessProofCondition/#return-values","text":"Name Type Description bytes32 uint256 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider , uint256 [ 2 ] _cipher , bytes _proof ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill key transfer The key with hash _origHash is transferred to the _buyer from _provider.","title":"Return Values:"},{"location":"contracts/conditions/AccessProofCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 associated agreement _origHash uint256 is the hash of data to access _buyer uint256[2] buyer public key _provider uint256[2] provider public key _cipher uint256[2] encrypted version of the key _proof bytes SNARK proof that the cipher text can be decrypted by buyer to give the key with hash _origHash","title":"Parameters:"},{"location":"contracts/conditions/AccessProofCondition/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"contracts/conditions/ComputeExecutionCondition/","text":"Implementation of the Compute Execution Condition This condition is meant to be a signal in which triggers the execution of a compute service. The compute service is fully described in the associated DID document. The provider of the compute service will send this signal to its workers by fulfilling the condition where they are listening to the fulfilled event. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _computeConsumer ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _computeConsumer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill compute execution condition only the compute provider can fulfill this condition. By fulfilling this condition the compute provider will trigger the execution of the offered job/compute. The compute service is described in a DID document. Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ### wasComputeTriggered function wasComputeTriggered ( bytes32 _did , address _computeConsumer ) public returns ( bool ) wasComputeTriggered checks whether the compute is triggered or not. Parameters: \u00b6 Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the compute consumer's address Return Values: \u00b6 Name Type Description true bytes32 if the compute is triggered ## Events ### Fulfilled event Fulfilled ( )","title":"ComputeExecutionCondition"},{"location":"contracts/conditions/ComputeExecutionCondition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/ComputeExecutionCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"contracts/conditions/ComputeExecutionCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address","title":"Parameters:"},{"location":"contracts/conditions/ComputeExecutionCondition/#hashvalues","text":"function hashValues ( bytes32 _did , address _computeConsumer ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/ComputeExecutionCondition/#parameters_1","text":"Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address","title":"Parameters:"},{"location":"contracts/conditions/ComputeExecutionCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _computeConsumer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill compute execution condition only the compute provider can fulfill this condition. By fulfilling this condition the compute provider will trigger the execution of the offered job/compute. The compute service is described in a DID document.","title":"Return Values:"},{"location":"contracts/conditions/ComputeExecutionCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 agreement identifier _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address","title":"Parameters:"},{"location":"contracts/conditions/ComputeExecutionCondition/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ### wasComputeTriggered function wasComputeTriggered ( bytes32 _did , address _computeConsumer ) public returns ( bool ) wasComputeTriggered checks whether the compute is triggered or not.","title":"Return Values:"},{"location":"contracts/conditions/ComputeExecutionCondition/#parameters_3","text":"Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the compute consumer's address","title":"Parameters:"},{"location":"contracts/conditions/ComputeExecutionCondition/#return-values_2","text":"Name Type Description true bytes32 if the compute is triggered ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"contracts/conditions/Condition/","text":"Implementation of the Condition Each condition has a validation function that returns either FULFILLED, ABORTED or UNFULFILLED. When a condition is successfully solved, we call it FULFILLED. If a condition cannot be FULFILLED anymore due to a timeout or other types of counter-proofs, the condition is ABORTED. UNFULFILLED values imply that a condition has not been provably FULFILLED or ABORTED. All initialized conditions start out as UNFULFILLED. Functions \u00b6 generateId \u00b6 function generateId ( bytes32 _agreementId , bytes32 _valueHash ) public returns ( bytes32 ) generateId condition Id from the following parameters Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement ID _valueHash bytes32 hash of all the condition input values fulfill \u00b6 function fulfill ( bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfill set the condition state to Fulfill | Abort Parameters: \u00b6 Name Type Description _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState new condition state (Fulfill/Abort) Return Values: \u00b6 Name Type Description the bytes32 updated condition state ### abortByTimeOut function abortByTimeOut ( bytes32 _id ) external returns ( enum ConditionStoreLibrary . ConditionState ) abortByTimeOut set condition state to Aborted if the condition is timed out Parameters: \u00b6 Name Type Description _id bytes32 condition identifier Return Values: \u00b6 Name Type Description the bytes32 updated condition state","title":"Condition"},{"location":"contracts/conditions/Condition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/Condition/#generateid","text":"function generateId ( bytes32 _agreementId , bytes32 _valueHash ) public returns ( bytes32 ) generateId condition Id from the following parameters","title":"generateId"},{"location":"contracts/conditions/Condition/#parameters","text":"Name Type Description _agreementId bytes32 SEA agreement ID _valueHash bytes32 hash of all the condition input values","title":"Parameters:"},{"location":"contracts/conditions/Condition/#fulfill","text":"function fulfill ( bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfill set the condition state to Fulfill | Abort","title":"fulfill"},{"location":"contracts/conditions/Condition/#parameters_1","text":"Name Type Description _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState new condition state (Fulfill/Abort)","title":"Parameters:"},{"location":"contracts/conditions/Condition/#return-values","text":"Name Type Description the bytes32 updated condition state ### abortByTimeOut function abortByTimeOut ( bytes32 _id ) external returns ( enum ConditionStoreLibrary . ConditionState ) abortByTimeOut set condition state to Aborted if the condition is timed out","title":"Return Values:"},{"location":"contracts/conditions/Condition/#parameters_2","text":"Name Type Description _id bytes32 condition identifier","title":"Parameters:"},{"location":"contracts/conditions/Condition/#return-values_1","text":"Name Type Description the bytes32 updated condition state","title":"Return Values:"},{"location":"contracts/conditions/ConditionStoreLibrary/","text":"Implementation of the Condition Store Library. Condition is a key component in the service execution agreement. This library holds the logic for creating and updating condition Any Condition has only four state transitions starts with Uninitialized, Unfulfilled, Fulfilled, and Aborted. Condition state transition goes only forward from Unintialized -> Unfulfilled -> {Fulfilled || Aborted} Functions \u00b6 create \u00b6 function create ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , address _typeRef , address _creator ) internal returns ( uint256 size ) create new condition check whether the condition exists, assigns condition type, condition state, last updated by, and update at (which is the current block number) Parameters: \u00b6 Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 valid condition identifier _typeRef address condition contract address _creator address address of the condition creator Return Values: \u00b6 Name Type Description size struct ConditionStoreLibrary.ConditionList is the condition index ### updateState function updateState ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal updateState update the condition state check whether the condition state transition is right, assign the new state, update last updated by and updated at. Parameters: \u00b6 Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState the new state of the condition","title":"ConditionStoreLibrary"},{"location":"contracts/conditions/ConditionStoreLibrary/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/ConditionStoreLibrary/#create","text":"function create ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , address _typeRef , address _creator ) internal returns ( uint256 size ) create new condition check whether the condition exists, assigns condition type, condition state, last updated by, and update at (which is the current block number)","title":"create"},{"location":"contracts/conditions/ConditionStoreLibrary/#parameters","text":"Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 valid condition identifier _typeRef address condition contract address _creator address address of the condition creator","title":"Parameters:"},{"location":"contracts/conditions/ConditionStoreLibrary/#return-values","text":"Name Type Description size struct ConditionStoreLibrary.ConditionList is the condition index ### updateState function updateState ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal updateState update the condition state check whether the condition state transition is right, assign the new state, update last updated by and updated at.","title":"Return Values:"},{"location":"contracts/conditions/ConditionStoreLibrary/#parameters_1","text":"Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState the new state of the condition","title":"Parameters:"},{"location":"contracts/conditions/ConditionStoreManager/","text":"Implementation of the Condition Store Manager. Condition store manager is responsible for enforcing the the business logic behind creating/updating the condition state based on the assigned role to each party. Only specific type of contracts are allowed to call this contract, therefore there are two types of roles, create role that in which is able to create conditions. The second role is the update role, which is can update the condition state. Also, it support delegating the roles to other contract(s)/account(s). Functions \u00b6 initialize \u00b6 function initialize ( address _owner ) public initialize ConditionStoreManager Initializer Initialize Ownable. Only on contract creation, Parameters: \u00b6 Name Type Description _owner address refers to the owner of the contract getCreateRole \u00b6 function getCreateRole ( ) external returns ( address ) getCreateRole get the address of contract which has the create role Return Values: \u00b6 Name Type Description create condition role address ### delegateCreateRole function delegateCreateRole ( address delegatee ) external delegateCreateRole only owner can delegate the create condition role to a different address Parameters: \u00b6 Name Type Description delegatee address delegatee address delegateUpdateRole \u00b6 function delegateUpdateRole ( bytes32 delegatee ) external delegateUpdateRole only owner can delegate the update role to a different address for specific condition Id which has the create role Parameters: \u00b6 Name Type Description delegatee bytes32 delegatee address createCondition \u00b6 function createCondition ( bytes32 _id , address _typeRef ) external returns ( uint256 size ) createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled. Parameters: \u00b6 Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address Return Values: \u00b6 Name Type Description size bytes32 the index of the created condition ### createCondition function createCondition ( bytes32 _id , address _typeRef , address _creator ) external returns ( uint256 size ) createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled. Parameters: \u00b6 Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address _creator address address of the condition creator Return Values: \u00b6 Name Type Description size bytes32 the index of the created condition ### createCondition function createCondition ( bytes32 _id , address _typeRef , uint256 _timeLock , uint256 _timeOut , address _creator ) public returns ( uint256 size ) createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled. Parameters: \u00b6 Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address _timeLock uint256 start of the time window _timeOut uint256 end of the time window _creator address address of the condition creator Return Values: \u00b6 Name Type Description size bytes32 the index of the created condition ### updateConditionState function updateConditionState ( bytes32 _id ) external returns ( enum ConditionStoreLibrary . ConditionState ) updateConditionState only called by update role address. It enforce the condition state transition to either Fulfill or Aborted state Parameters: \u00b6 Name Type Description _id bytes32 unique condition identifier Return Values: \u00b6 Name Type Description the bytes32 current condition state ### getConditionListSize function getConditionListSize ( ) external returns ( uint256 size ) getConditionListSize Return Values: \u00b6 Name Type Description size the length of the condition list ### getCondition function getCondition ( ) external returns ( address typeRef , enum ConditionStoreLibrary . ConditionState state , uint256 timeLock , uint256 timeOut , uint256 blockNumber , address createdBy , address lastUpdatedBy , uint256 blockNumberUpdated ) getCondition Return Values: \u00b6 Name Type Description typeRef bytes32 the type reference state condition state timeLock the time lock timeOut time out blockNumber block number createdBy address lastUpdatedBy address blockNumberUpdated block number updated ### getConditionState function getConditionState ( ) external returns ( enum ConditionStoreLibrary . ConditionState ) getConditionState Return Values: \u00b6 Name Type Description condition bytes32 state ### getConditionTypeRef function getConditionTypeRef ( ) external returns ( address ) getConditionTypeRef Return Values: \u00b6 Name Type Description condition bytes32 typeRef ### getConditionCreatedBy function getConditionCreatedBy ( ) external returns ( address ) getConditionCreatedBy Return Values: \u00b6 Name Type Description condition bytes32 createdBy address ### isConditionTimeLocked function isConditionTimeLocked ( ) public returns ( bool ) isConditionTimeLocked Return Values: \u00b6 Name Type Description whether bytes32 the condition is timedLock ended ### isConditionTimedOut function isConditionTimedOut ( ) public returns ( bool ) isConditionTimedOut Return Values: \u00b6 Name Type Description whether bytes32 the condition is timed out ## Events ### ConditionCreated event ConditionCreated ( ) ConditionUpdated \u00b6 event ConditionUpdated ( )","title":"ConditionStoreManager"},{"location":"contracts/conditions/ConditionStoreManager/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/ConditionStoreManager/#initialize","text":"function initialize ( address _owner ) public initialize ConditionStoreManager Initializer Initialize Ownable. Only on contract creation,","title":"initialize"},{"location":"contracts/conditions/ConditionStoreManager/#parameters","text":"Name Type Description _owner address refers to the owner of the contract","title":"Parameters:"},{"location":"contracts/conditions/ConditionStoreManager/#getcreaterole","text":"function getCreateRole ( ) external returns ( address ) getCreateRole get the address of contract which has the create role","title":"getCreateRole"},{"location":"contracts/conditions/ConditionStoreManager/#return-values","text":"Name Type Description create condition role address ### delegateCreateRole function delegateCreateRole ( address delegatee ) external delegateCreateRole only owner can delegate the create condition role to a different address","title":"Return Values:"},{"location":"contracts/conditions/ConditionStoreManager/#parameters_1","text":"Name Type Description delegatee address delegatee address","title":"Parameters:"},{"location":"contracts/conditions/ConditionStoreManager/#delegateupdaterole","text":"function delegateUpdateRole ( bytes32 delegatee ) external delegateUpdateRole only owner can delegate the update role to a different address for specific condition Id which has the create role","title":"delegateUpdateRole"},{"location":"contracts/conditions/ConditionStoreManager/#parameters_2","text":"Name Type Description delegatee bytes32 delegatee address","title":"Parameters:"},{"location":"contracts/conditions/ConditionStoreManager/#createcondition","text":"function createCondition ( bytes32 _id , address _typeRef ) external returns ( uint256 size ) createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled.","title":"createCondition"},{"location":"contracts/conditions/ConditionStoreManager/#parameters_3","text":"Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address","title":"Parameters:"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_1","text":"Name Type Description size bytes32 the index of the created condition ### createCondition function createCondition ( bytes32 _id , address _typeRef , address _creator ) external returns ( uint256 size ) createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled.","title":"Return Values:"},{"location":"contracts/conditions/ConditionStoreManager/#parameters_4","text":"Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address _creator address address of the condition creator","title":"Parameters:"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_2","text":"Name Type Description size bytes32 the index of the created condition ### createCondition function createCondition ( bytes32 _id , address _typeRef , uint256 _timeLock , uint256 _timeOut , address _creator ) public returns ( uint256 size ) createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled.","title":"Return Values:"},{"location":"contracts/conditions/ConditionStoreManager/#parameters_5","text":"Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address _timeLock uint256 start of the time window _timeOut uint256 end of the time window _creator address address of the condition creator","title":"Parameters:"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_3","text":"Name Type Description size bytes32 the index of the created condition ### updateConditionState function updateConditionState ( bytes32 _id ) external returns ( enum ConditionStoreLibrary . ConditionState ) updateConditionState only called by update role address. It enforce the condition state transition to either Fulfill or Aborted state","title":"Return Values:"},{"location":"contracts/conditions/ConditionStoreManager/#parameters_6","text":"Name Type Description _id bytes32 unique condition identifier","title":"Parameters:"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_4","text":"Name Type Description the bytes32 current condition state ### getConditionListSize function getConditionListSize ( ) external returns ( uint256 size ) getConditionListSize","title":"Return Values:"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_5","text":"Name Type Description size the length of the condition list ### getCondition function getCondition ( ) external returns ( address typeRef , enum ConditionStoreLibrary . ConditionState state , uint256 timeLock , uint256 timeOut , uint256 blockNumber , address createdBy , address lastUpdatedBy , uint256 blockNumberUpdated ) getCondition","title":"Return Values:"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_6","text":"Name Type Description typeRef bytes32 the type reference state condition state timeLock the time lock timeOut time out blockNumber block number createdBy address lastUpdatedBy address blockNumberUpdated block number updated ### getConditionState function getConditionState ( ) external returns ( enum ConditionStoreLibrary . ConditionState ) getConditionState","title":"Return Values:"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_7","text":"Name Type Description condition bytes32 state ### getConditionTypeRef function getConditionTypeRef ( ) external returns ( address ) getConditionTypeRef","title":"Return Values:"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_8","text":"Name Type Description condition bytes32 typeRef ### getConditionCreatedBy function getConditionCreatedBy ( ) external returns ( address ) getConditionCreatedBy","title":"Return Values:"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_9","text":"Name Type Description condition bytes32 createdBy address ### isConditionTimeLocked function isConditionTimeLocked ( ) public returns ( bool ) isConditionTimeLocked","title":"Return Values:"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_10","text":"Name Type Description whether bytes32 the condition is timedLock ended ### isConditionTimedOut function isConditionTimedOut ( ) public returns ( bool ) isConditionTimedOut","title":"Return Values:"},{"location":"contracts/conditions/ConditionStoreManager/#return-values_11","text":"Name Type Description whether bytes32 the condition is timed out ## Events ### ConditionCreated event ConditionCreated ( )","title":"Return Values:"},{"location":"contracts/conditions/ConditionStoreManager/#conditionupdated","text":"event ConditionUpdated ( )","title":"ConditionUpdated"},{"location":"contracts/conditions/HashLockCondition/","text":"Implementation of the Hash Lock Condition Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( uint256 _preimage ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _preimage uint256 refers uint value of the hash pre-image. Return Values: \u00b6 Name Type Description bytes32 uint256 hash of all these values ### hashValues function hashValues ( string _preimage ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _preimage string refers string value of the hash pre-image. Return Values: \u00b6 Name Type Description bytes32 string hash of all these values ### hashValues function hashValues ( bytes32 _preimage ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _preimage bytes32 refers bytes32 value of the hash pre-image. Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image uint value Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier Return Values: \u00b6 Name Type Description condition bytes32 state ### fulfill function fulfill ( bytes32 _agreementId ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image string value Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier Return Values: \u00b6 Name Type Description condition bytes32 state ### fulfill function fulfill ( bytes32 _agreementId ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image bytes32 value Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier Return Values: \u00b6 Name Type Description condition bytes32 state","title":"HashLockCondition"},{"location":"contracts/conditions/HashLockCondition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/HashLockCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"contracts/conditions/HashLockCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"Parameters:"},{"location":"contracts/conditions/HashLockCondition/#hashvalues","text":"function hashValues ( uint256 _preimage ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/HashLockCondition/#parameters_1","text":"Name Type Description _preimage uint256 refers uint value of the hash pre-image.","title":"Parameters:"},{"location":"contracts/conditions/HashLockCondition/#return-values","text":"Name Type Description bytes32 uint256 hash of all these values ### hashValues function hashValues ( string _preimage ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"Return Values:"},{"location":"contracts/conditions/HashLockCondition/#parameters_2","text":"Name Type Description _preimage string refers string value of the hash pre-image.","title":"Parameters:"},{"location":"contracts/conditions/HashLockCondition/#return-values_1","text":"Name Type Description bytes32 string hash of all these values ### hashValues function hashValues ( bytes32 _preimage ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"Return Values:"},{"location":"contracts/conditions/HashLockCondition/#parameters_3","text":"Name Type Description _preimage bytes32 refers bytes32 value of the hash pre-image.","title":"Parameters:"},{"location":"contracts/conditions/HashLockCondition/#return-values_2","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image uint value","title":"Return Values:"},{"location":"contracts/conditions/HashLockCondition/#parameters_4","text":"Name Type Description _agreementId bytes32 SEA agreement identifier","title":"Parameters:"},{"location":"contracts/conditions/HashLockCondition/#return-values_3","text":"Name Type Description condition bytes32 state ### fulfill function fulfill ( bytes32 _agreementId ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image string value","title":"Return Values:"},{"location":"contracts/conditions/HashLockCondition/#parameters_5","text":"Name Type Description _agreementId bytes32 SEA agreement identifier","title":"Parameters:"},{"location":"contracts/conditions/HashLockCondition/#return-values_4","text":"Name Type Description condition bytes32 state ### fulfill function fulfill ( bytes32 _agreementId ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image bytes32 value","title":"Return Values:"},{"location":"contracts/conditions/HashLockCondition/#parameters_6","text":"Name Type Description _agreementId bytes32 SEA agreement identifier","title":"Parameters:"},{"location":"contracts/conditions/HashLockCondition/#return-values_5","text":"Name Type Description condition bytes32 state","title":"Return Values:"},{"location":"contracts/conditions/IDisputeManager/","text":"Functions \u00b6 verifyProof \u00b6 function verifyProof ( ) external returns ( bool )","title":"IDisputeManager"},{"location":"contracts/conditions/IDisputeManager/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/IDisputeManager/#verifyproof","text":"function verifyProof ( ) external returns ( bool )","title":"verifyProof"},{"location":"contracts/conditions/LockPaymentCondition/","text":"Implementation of the Lock Payment Condition This condition allows to lock payment for multiple receivers taking into account the royalties to be paid to the original creators in a secondary market. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address hashValues \u00b6 function hashValues ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid token transfer in order to lock the amount of tokens based on the SEA Parameters: \u00b6 Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Return Values: \u00b6 Name Type Description condition bytes32 state ### _transferERC20 function _transferERC20 ( address _rewardAddress , address _tokenAddress , uint256 _amount ) internal _transferERC20 transfer ERC20 tokens Will throw if transfer fails Parameters: \u00b6 Name Type Description _rewardAddress address the address to receive the tokens _tokenAddress address the ERC20 contract address to use during the payment _amount uint256 token amount to be locked/released _transferETH \u00b6 function _transferETH ( address payable _rewardAddress , uint256 _amount ) internal _transferETH transfer ETH Parameters: \u00b6 Name Type Description _rewardAddress address payable the address to receive the ETH _amount uint256 ETH amount to be locked/released Events \u00b6 Fulfilled \u00b6 event Fulfilled ( )","title":"LockPaymentCondition"},{"location":"contracts/conditions/LockPaymentCondition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/LockPaymentCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"contracts/conditions/LockPaymentCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address","title":"Parameters:"},{"location":"contracts/conditions/LockPaymentCondition/#hashvalues","text":"function hashValues ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/LockPaymentCondition/#parameters_1","text":"Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses","title":"Parameters:"},{"location":"contracts/conditions/LockPaymentCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid token transfer in order to lock the amount of tokens based on the SEA","title":"Return Values:"},{"location":"contracts/conditions/LockPaymentCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses","title":"Parameters:"},{"location":"contracts/conditions/LockPaymentCondition/#return-values_1","text":"Name Type Description condition bytes32 state ### _transferERC20 function _transferERC20 ( address _rewardAddress , address _tokenAddress , uint256 _amount ) internal _transferERC20 transfer ERC20 tokens Will throw if transfer fails","title":"Return Values:"},{"location":"contracts/conditions/LockPaymentCondition/#parameters_3","text":"Name Type Description _rewardAddress address the address to receive the tokens _tokenAddress address the ERC20 contract address to use during the payment _amount uint256 token amount to be locked/released","title":"Parameters:"},{"location":"contracts/conditions/LockPaymentCondition/#_transfereth","text":"function _transferETH ( address payable _rewardAddress , uint256 _amount ) internal _transferETH transfer ETH","title":"_transferETH"},{"location":"contracts/conditions/LockPaymentCondition/#parameters_4","text":"Name Type Description _rewardAddress address payable the address to receive the ETH _amount uint256 ETH amount to be locked/released","title":"Parameters:"},{"location":"contracts/conditions/LockPaymentCondition/#events","text":"","title":"Events"},{"location":"contracts/conditions/LockPaymentCondition/#fulfilled","text":"event Fulfilled ( )","title":"Fulfilled"},{"location":"contracts/conditions/SignCondition/","text":"Implementation of the Sign Condition Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _message , address _publicKey ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _message bytes32 the message to be signed _publicKey address the public key of the signing address Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _message , address _publicKey , bytes _signature ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill validate the signed message and fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier _message bytes32 the message to be signed _publicKey address the public key of the signing address _signature bytes signature of the signed message using the public key Return Values: \u00b6 Name Type Description condition bytes32 state","title":"SignCondition"},{"location":"contracts/conditions/SignCondition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/SignCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"contracts/conditions/SignCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"Parameters:"},{"location":"contracts/conditions/SignCondition/#hashvalues","text":"function hashValues ( bytes32 _message , address _publicKey ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/SignCondition/#parameters_1","text":"Name Type Description _message bytes32 the message to be signed _publicKey address the public key of the signing address","title":"Parameters:"},{"location":"contracts/conditions/SignCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _message , address _publicKey , bytes _signature ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill validate the signed message and fulfill the condition","title":"Return Values:"},{"location":"contracts/conditions/SignCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 SEA agreement identifier _message bytes32 the message to be signed _publicKey address the public key of the signing address _signature bytes signature of the signed message using the public key","title":"Parameters:"},{"location":"contracts/conditions/SignCondition/#return-values_1","text":"Name Type Description condition bytes32 state","title":"Return Values:"},{"location":"contracts/conditions/ThresholdCondition/","text":"Implementation of the Threshold Condition Threshold condition acts as a filter for a set of input condition(s) in which sends a signal whether to complete the flow execution or abort it. This type of conditions works as intermediary conditions where they wire SEA conditions in order to support more complex scenarios. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 [] inputConditions , uint256 threshold ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Return Values: \u00b6 Name Type Description bytes32 bytes32[] hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 [] _inputConditions , uint256 threshold ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill threshold condition the fulfill method check whether input conditions are fulfilled or not. Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted)","title":"ThresholdCondition"},{"location":"contracts/conditions/ThresholdCondition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/ThresholdCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"contracts/conditions/ThresholdCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"Parameters:"},{"location":"contracts/conditions/ThresholdCondition/#hashvalues","text":"function hashValues ( bytes32 [] inputConditions , uint256 threshold ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/ThresholdCondition/#parameters_1","text":"Name Type Description inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions","title":"Parameters:"},{"location":"contracts/conditions/ThresholdCondition/#return-values","text":"Name Type Description bytes32 bytes32[] hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 [] _inputConditions , uint256 threshold ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill threshold condition the fulfill method check whether input conditions are fulfilled or not.","title":"Return Values:"},{"location":"contracts/conditions/ThresholdCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 agreement identifier _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions","title":"Parameters:"},{"location":"contracts/conditions/ThresholdCondition/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted)","title":"Return Values:"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/","text":"Implementation of condition allowing to transfer the ownership between the original owner and a receiver Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address hashValues \u00b6 function hashValues ( bytes32 _did , address _receiver ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user or the DID provider Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _receiver ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer DID ownership condition only DID owner or DID provider can call this method. Fulfill method transfer full ownership permissions to to _receiver address. When true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"TransferDIDOwnershipCondition"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address","title":"Parameters:"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#hashvalues","text":"function hashValues ( bytes32 _did , address _receiver ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#parameters_1","text":"Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user or the DID provider","title":"Parameters:"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _receiver ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer DID ownership condition only DID owner or DID provider can call this method. Fulfill method transfer full ownership permissions to to _receiver address. When true then fulfill the condition","title":"Return Values:"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user","title":"Parameters:"},{"location":"contracts/conditions/TransferDIDOwnershipCondition/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"contracts/conditions/WhitelistingCondition/","text":"Implementation of the Whitelisting Condition Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( address _listAddress , bytes32 _item ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _listAddress address list contract address _item bytes32 item in the list Return Values: \u00b6 Name Type Description bytes32 address hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , address _listAddress , bytes32 _item ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill check whether address is whitelisted in order to fulfill the condition. This method will be called by any one in this whitelist. Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier _listAddress address list contract address _item bytes32 item in the list Return Values: \u00b6 Name Type Description condition bytes32 state","title":"WhitelistingCondition"},{"location":"contracts/conditions/WhitelistingCondition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/WhitelistingCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"contracts/conditions/WhitelistingCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"Parameters:"},{"location":"contracts/conditions/WhitelistingCondition/#hashvalues","text":"function hashValues ( address _listAddress , bytes32 _item ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/WhitelistingCondition/#parameters_1","text":"Name Type Description _listAddress address list contract address _item bytes32 item in the list","title":"Parameters:"},{"location":"contracts/conditions/WhitelistingCondition/#return-values","text":"Name Type Description bytes32 address hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , address _listAddress , bytes32 _item ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill check whether address is whitelisted in order to fulfill the condition. This method will be called by any one in this whitelist.","title":"Return Values:"},{"location":"contracts/conditions/WhitelistingCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 SEA agreement identifier _listAddress address list contract address _item bytes32 item in the list","title":"Parameters:"},{"location":"contracts/conditions/WhitelistingCondition/#return-values_1","text":"Name Type Description condition bytes32 state","title":"Return Values:"},{"location":"contracts/conditions/NFTs/INFTAccess/","text":"Functions \u00b6 hashValues \u00b6 function hashValues ( bytes32 _documentId , address _grantee , address _contractAddress ) external returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access conditions only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"INFTAccess"},{"location":"contracts/conditions/NFTs/INFTAccess/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/NFTs/INFTAccess/#hashvalues","text":"function hashValues ( bytes32 _documentId , address _grantee , address _contractAddress ) external returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/NFTs/INFTAccess/#parameters","text":"Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155)","title":"Parameters:"},{"location":"contracts/conditions/NFTs/INFTAccess/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access conditions only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition","title":"Return Values:"},{"location":"contracts/conditions/NFTs/INFTAccess/#parameters_1","text":"Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155)","title":"Parameters:"},{"location":"contracts/conditions/NFTs/INFTAccess/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"contracts/conditions/NFTs/INFTHolder/","text":"Functions \u00b6 hashValues \u00b6 function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Return Values: \u00b6 Name Type Description condition bytes32 state ## Events ### Fulfilled event Fulfilled ( )","title":"INFTHolder"},{"location":"contracts/conditions/NFTs/INFTHolder/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/NFTs/INFTHolder/#hashvalues","text":"function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/NFTs/INFTHolder/#parameters","text":"Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155)","title":"Parameters:"},{"location":"contracts/conditions/NFTs/INFTHolder/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID","title":"Return Values:"},{"location":"contracts/conditions/NFTs/INFTHolder/#parameters_1","text":"Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155)","title":"Parameters:"},{"location":"contracts/conditions/NFTs/INFTHolder/#return-values_1","text":"Name Type Description condition bytes32 state ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"contracts/conditions/NFTs/ITransferNFT/","text":"Functions \u00b6 hashValues \u00b6 function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition ) external returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"ITransferNFT"},{"location":"contracts/conditions/NFTs/ITransferNFT/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/NFTs/ITransferNFT/#hashvalues","text":"function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition ) external returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/NFTs/ITransferNFT/#parameters","text":"Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier","title":"Parameters:"},{"location":"contracts/conditions/NFTs/ITransferNFT/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition","title":"Return Values:"},{"location":"contracts/conditions/NFTs/ITransferNFT/#parameters_1","text":"Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier","title":"Parameters:"},{"location":"contracts/conditions/NFTs/ITransferNFT/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"contracts/conditions/NFTs/NFT721HolderCondition/","text":"Implementation of the Nft Holder Condition Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( ) public returns ( bytes32 ) fulfill \u00b6 function fulfill ( ) external returns ( enum ConditionStoreLibrary . ConditionState )","title":"NFT721HolderCondition"},{"location":"contracts/conditions/NFTs/NFT721HolderCondition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/NFTs/NFT721HolderCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"contracts/conditions/NFTs/NFT721HolderCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"Parameters:"},{"location":"contracts/conditions/NFTs/NFT721HolderCondition/#hashvalues","text":"function hashValues ( ) public returns ( bytes32 )","title":"hashValues"},{"location":"contracts/conditions/NFTs/NFT721HolderCondition/#fulfill","text":"function fulfill ( ) external returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfill"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/","text":"Implementation of the Access Condition specific for NFTs NFT Access Condition is special condition used to give access to a specific NFT related to a DID. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID registry address hashValues \u00b6 function hashValues ( bytes32 _documentId , address _grantee ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### hashValues function hashValues ( ) public returns ( bytes32 ) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address is the contract address of the NFT implementation (ERC-1155 or ERC-721) Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ### grantPermission function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider Parameters: \u00b6 Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys checkPermissions \u00b6 function checkPermissions ( address _documentId , bytes32 _grantee ) external returns ( bool permissionGranted ) checkPermissions is called to validate the permissions of user related to the NFT attached to an asset Parameters: \u00b6 Name Type Description _documentId address refers to the DID _grantee bytes32 is the address of the granted user or the DID provider Return Values: \u00b6 Name Type Description permissionGranted address true if the access was granted","title":"NFTAccessCondition"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID registry address","title":"Parameters:"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#hashvalues","text":"function hashValues ( bytes32 _documentId , address _grantee ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#parameters_1","text":"Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider","title":"Parameters:"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### hashValues function hashValues ( ) public returns ( bytes32 )","title":"Return Values:"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#fulfill","text":"function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition","title":"fulfill"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider","title":"Parameters:"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition","title":"Return Values:"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#parameters_3","text":"Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address is the contract address of the NFT implementation (ERC-1155 or ERC-721)","title":"Parameters:"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#return-values_2","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ### grantPermission function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider","title":"Return Values:"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#parameters_4","text":"Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys","title":"Parameters:"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#checkpermissions","text":"function checkPermissions ( address _documentId , bytes32 _grantee ) external returns ( bool permissionGranted ) checkPermissions is called to validate the permissions of user related to the NFT attached to an asset","title":"checkPermissions"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#parameters_5","text":"Name Type Description _documentId address refers to the DID _grantee bytes32 is the address of the granted user or the DID provider","title":"Parameters:"},{"location":"contracts/conditions/NFTs/NFTAccessCondition/#return-values_3","text":"Name Type Description permissionGranted address true if the access was granted","title":"Return Values:"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/","text":"Implementation of the Nft Holder Condition Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DIDRegistry address hashValues \u00b6 function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### hashValues function hashValues ( ) public returns ( bytes32 ) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold Return Values: \u00b6 Name Type Description condition bytes32 state ### fulfill function fulfill ( ) public returns ( enum ConditionStoreLibrary . ConditionState )","title":"NFTHolderCondition"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DIDRegistry address","title":"Parameters:"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#hashvalues","text":"function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#parameters_1","text":"Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder","title":"Parameters:"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### hashValues function hashValues ( ) public returns ( bytes32 )","title":"Return Values:"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#fulfill","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID","title":"fulfill"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold","title":"Parameters:"},{"location":"contracts/conditions/NFTs/NFTHolderCondition/#return-values_1","text":"Name Type Description condition bytes32 state ### fulfill function fulfill ( ) public returns ( enum ConditionStoreLibrary . ConditionState )","title":"Return Values:"},{"location":"contracts/conditions/NFTs/NFTLockCondition/","text":"Implementation of the NFT Lock Condition Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DIDRegistry contract address hashValues \u00b6 function hashValues ( bytes32 _did , address _rewardAddress , uint256 _amount ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _rewardAddress address the final address to receive the NFTs _amount uint256 is the amount of the locked tokens Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _rewardAddress , uint256 _amount ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid NFT transfer in order to lock the amount of DID NFTs based on the SEA Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 Asset Decentralized Identifier _rewardAddress address the contract address where the reward is locked _amount uint256 is the amount of tokens to be transferred Return Values: \u00b6 Name Type Description condition bytes32 state ### onERC1155Received function onERC1155Received ( ) external returns ( bytes4 ) onERC1155BatchReceived \u00b6 function onERC1155BatchReceived ( ) external returns ( bytes4 ) supportsInterface \u00b6 function supportsInterface ( ) external returns ( bool ) Events \u00b6 Fulfilled \u00b6 event Fulfilled ( )","title":"NFTLockCondition"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DIDRegistry contract address","title":"Parameters:"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#hashvalues","text":"function hashValues ( bytes32 _did , address _rewardAddress , uint256 _amount ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#parameters_1","text":"Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _rewardAddress address the final address to receive the NFTs _amount uint256 is the amount of the locked tokens","title":"Parameters:"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _rewardAddress , uint256 _amount ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid NFT transfer in order to lock the amount of DID NFTs based on the SEA","title":"Return Values:"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 Asset Decentralized Identifier _rewardAddress address the contract address where the reward is locked _amount uint256 is the amount of tokens to be transferred","title":"Parameters:"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#return-values_1","text":"Name Type Description condition bytes32 state ### onERC1155Received function onERC1155Received ( ) external returns ( bytes4 )","title":"Return Values:"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#onerc1155batchreceived","text":"function onERC1155BatchReceived ( ) external returns ( bytes4 )","title":"onERC1155BatchReceived"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#supportsinterface","text":"function supportsInterface ( ) external returns ( bool )","title":"supportsInterface"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#events","text":"","title":"Events"},{"location":"contracts/conditions/NFTs/NFTLockCondition/#fulfilled","text":"event Fulfilled ( )","title":"Fulfilled"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/","text":"Implementation of condition allowing to transfer an NFT between the original owner and a receiver Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address hashValues \u00b6 function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition , bytes32 _contract ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier _contract bytes32 NFT contract to use Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address NFT contract to use Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted)","title":"TransferNFT721Condition"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address","title":"Parameters:"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#hashvalues","text":"function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition , bytes32 _contract ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#parameters_1","text":"Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier _contract bytes32 NFT contract to use","title":"Parameters:"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition","title":"Return Values:"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#parameters_2","text":"Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address NFT contract to use","title":"Parameters:"},{"location":"contracts/conditions/NFTs/TransferNFT721Condition/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted)","title":"Return Values:"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/","text":"Implementation of condition allowing to transfer an NFT between the original owner and a receiver Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress , address _nftContractAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _nftContractAddress address Market address grantMarketRole \u00b6 function grantMarketRole ( ) public revokeMarketRole \u00b6 function revokeMarketRole ( ) public hashValues \u00b6 function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### hashValues function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition , bytes32 _nftContractAddress ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier _nftContractAddress bytes32 NFT contract to use Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address NFT contract to use Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ### fulfillForMarket function fulfillForMarket ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockPaymentCondition , bytes32 _nftHolder ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount address amount of NFTs to transfer _lockPaymentCondition uint256 lock payment condition identifier _nftHolder bytes32 is the address of the account to receive the NFT Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted)","title":"TransferNFTCondition"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress , address _nftContractAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _nftContractAddress address Market address","title":"Parameters:"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#grantmarketrole","text":"function grantMarketRole ( ) public","title":"grantMarketRole"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#revokemarketrole","text":"function revokeMarketRole ( ) public","title":"revokeMarketRole"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#hashvalues","text":"function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#parameters_1","text":"Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier","title":"Parameters:"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### hashValues function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition , bytes32 _nftContractAddress ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"Return Values:"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#parameters_2","text":"Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier _nftContractAddress bytes32 NFT contract to use","title":"Parameters:"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#return-values_1","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( ) public returns ( enum ConditionStoreLibrary . ConditionState )","title":"Return Values:"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#fulfill","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition","title":"fulfill"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#parameters_3","text":"Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address NFT contract to use","title":"Parameters:"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#return-values_2","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ### fulfillForMarket function fulfillForMarket ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockPaymentCondition , bytes32 _nftHolder ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition","title":"Return Values:"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#parameters_4","text":"Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount address amount of NFTs to transfer _lockPaymentCondition uint256 lock payment condition identifier _nftHolder bytes32 is the address of the account to receive the NFT","title":"Parameters:"},{"location":"contracts/conditions/NFTs/TransferNFTCondition/#return-values_3","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted)","title":"Return Values:"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/","text":"Implementation of the Escrow Payment Condition The Escrow payment is reward condition in which only can release reward if lock and release conditions are fulfilled. Functions \u00b6 receive \u00b6 function receive ( ) external initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseCondition bytes32 release condition identifier Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### hashValuesLockPayment function hashValuesLockPayment ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively. Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseCondition bytes32 release condition identifier Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( ) Received \u00b6 event Received ( )","title":"EscrowPaymentCondition"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#functions","text":"","title":"Functions"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#receive","text":"function receive ( ) external","title":"receive"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters","title":"initialize"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"Parameters:"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#hashvalues","text":"function hashValues ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#parameters_1","text":"Name Type Description _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseCondition bytes32 release condition identifier","title":"Parameters:"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### hashValuesLockPayment function hashValuesLockPayment ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters","title":"Return Values:"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#parameters_2","text":"Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses","title":"Parameters:"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#return-values_1","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively.","title":"Return Values:"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#parameters_3","text":"Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseCondition bytes32 release condition identifier","title":"Parameters:"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#return-values_2","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"contracts/conditions/rewards/EscrowPaymentCondition/#received","text":"event Received ( )","title":"Received"},{"location":"contracts/conditions/rewards/Reward/","text":"Implementation of the Reward. Generic reward condition","title":"Reward"},{"location":"contracts/interfaces/IList/","text":"Functions \u00b6 has \u00b6 function has ( ) external returns ( bool ) has \u00b6 function has ( ) external returns ( bool )","title":"IList"},{"location":"contracts/interfaces/IList/#functions","text":"","title":"Functions"},{"location":"contracts/interfaces/IList/#has","text":"function has ( ) external returns ( bool )","title":"has"},{"location":"contracts/interfaces/IList/#has_1","text":"function has ( ) external returns ( bool )","title":"has"},{"location":"contracts/interfaces/ISecretStore/","text":"Functions \u00b6 checkPermissions \u00b6 function checkPermissions ( ) external returns ( bool permissionGranted ) checkPermissions is called by Parity secret store","title":"ISecretStore"},{"location":"contracts/interfaces/ISecretStore/#functions","text":"","title":"Functions"},{"location":"contracts/interfaces/ISecretStore/#checkpermissions","text":"function checkPermissions ( ) external returns ( bool permissionGranted ) checkPermissions is called by Parity secret store","title":"checkPermissions"},{"location":"contracts/interfaces/ISecretStorePermission/","text":"Functions \u00b6 grantPermission \u00b6 function grantPermission ( ) external grantPermission is called only by documentKeyId Owner or provider renouncePermission \u00b6 function renouncePermission ( ) external renouncePermission is called only by documentKeyId Owner or provider","title":"ISecretStorePermission"},{"location":"contracts/interfaces/ISecretStorePermission/#functions","text":"","title":"Functions"},{"location":"contracts/interfaces/ISecretStorePermission/#grantpermission","text":"function grantPermission ( ) external grantPermission is called only by documentKeyId Owner or provider","title":"grantPermission"},{"location":"contracts/interfaces/ISecretStorePermission/#renouncepermission","text":"function renouncePermission ( ) external renouncePermission is called only by documentKeyId Owner or provider","title":"renouncePermission"},{"location":"contracts/libraries/EpochLibrary/","text":"Implementation of Epoch Library. For an arbitrary Epoch, this library manages the life cycle of an Epoch. Usually this library is used for handling the time window between conditions in an agreement. For more information about Epoch checkout the below link https://github.com/oceanprotocol/OEPs/issues/119 TODO: update to the OEP link Functions \u00b6 create \u00b6 function create ( struct EpochLibrary . EpochList _self , bytes32 _timeLock , uint256 _timeOut ) internal create creates new Epoch Parameters: \u00b6 Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _timeLock bytes32 value in block count (can not fulfill before) _timeOut uint256 value in block count (can not fulfill after) isTimedOut \u00b6 function isTimedOut ( struct EpochLibrary . EpochList _self ) external returns ( bool ) isTimedOut means you cannot fulfill after Parameters: \u00b6 Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer Return Values: \u00b6 Name Type Description true struct EpochLibrary.EpochList if the current block number is gt timeOut ### isTimeLocked function isTimeLocked ( struct EpochLibrary . EpochList _self ) external returns ( bool ) isTimeLocked means you cannot fulfill before Parameters: \u00b6 Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer Return Values: \u00b6 Name Type Description true struct EpochLibrary.EpochList if the current block number is gt timeLock ### getEpochTimeOut function getEpochTimeOut ( struct EpochLibrary . Epoch _self ) public returns ( uint256 ) getEpochTimeOut Parameters: \u00b6 Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer getEpochTimeLock \u00b6 function getEpochTimeLock ( struct EpochLibrary . Epoch _self ) public returns ( uint256 ) getEpochTimeLock Parameters: \u00b6 Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer","title":"EpochLibrary"},{"location":"contracts/libraries/EpochLibrary/#functions","text":"","title":"Functions"},{"location":"contracts/libraries/EpochLibrary/#create","text":"function create ( struct EpochLibrary . EpochList _self , bytes32 _timeLock , uint256 _timeOut ) internal create creates new Epoch","title":"create"},{"location":"contracts/libraries/EpochLibrary/#parameters","text":"Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _timeLock bytes32 value in block count (can not fulfill before) _timeOut uint256 value in block count (can not fulfill after)","title":"Parameters:"},{"location":"contracts/libraries/EpochLibrary/#istimedout","text":"function isTimedOut ( struct EpochLibrary . EpochList _self ) external returns ( bool ) isTimedOut means you cannot fulfill after","title":"isTimedOut"},{"location":"contracts/libraries/EpochLibrary/#parameters_1","text":"Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer","title":"Parameters:"},{"location":"contracts/libraries/EpochLibrary/#return-values","text":"Name Type Description true struct EpochLibrary.EpochList if the current block number is gt timeOut ### isTimeLocked function isTimeLocked ( struct EpochLibrary . EpochList _self ) external returns ( bool ) isTimeLocked means you cannot fulfill before","title":"Return Values:"},{"location":"contracts/libraries/EpochLibrary/#parameters_2","text":"Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer","title":"Parameters:"},{"location":"contracts/libraries/EpochLibrary/#return-values_1","text":"Name Type Description true struct EpochLibrary.EpochList if the current block number is gt timeLock ### getEpochTimeOut function getEpochTimeOut ( struct EpochLibrary . Epoch _self ) public returns ( uint256 ) getEpochTimeOut","title":"Return Values:"},{"location":"contracts/libraries/EpochLibrary/#parameters_3","text":"Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer","title":"Parameters:"},{"location":"contracts/libraries/EpochLibrary/#getepochtimelock","text":"function getEpochTimeLock ( struct EpochLibrary . Epoch _self ) public returns ( uint256 ) getEpochTimeLock","title":"getEpochTimeLock"},{"location":"contracts/libraries/EpochLibrary/#parameters_4","text":"Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer","title":"Parameters:"},{"location":"contracts/libraries/HashListLibrary/","text":"Implementation of the basic functionality of list of hash values. This library allows other contracts to build and maintain lists and also preserves the privacy of the data by accepting only hashed content (bytes32 based data type) Functions \u00b6 add \u00b6 function add ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) add index an element then add it to a list Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is a bytes32 value Return Values: \u00b6 Name Type Description true struct HashListLibrary.List if value is added successfully ### add function add ( struct HashListLibrary . List _self , bytes32 [] values ) public returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage values bytes32[] is an array of elements value Return Values: \u00b6 Name Type Description true struct HashListLibrary.List if values are added successfully ### update function update ( struct HashListLibrary . List _self , bytes32 oldValue , bytes32 newValue ) public returns ( bool ) update the value with a new value and maintain indices Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage oldValue bytes32 is an element value in a list newValue bytes32 new value Return Values: \u00b6 Name Type Description true struct HashListLibrary.List if value is updated successfully ### remove function remove ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) remove value from a list, updates indices, and list size Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is an element value in a list Return Values: \u00b6 Name Type Description true struct HashListLibrary.List if value is removed successfully ### get function get ( struct HashListLibrary . List _self , uint256 index ) public returns ( bytes32 ) has value by index Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage index uint256 is where is value is stored in the list Return Values: \u00b6 Name Type Description the struct HashListLibrary.List value if exists ### index function index ( struct HashListLibrary . List _self , uint256 from , uint256 to ) public returns ( bool ) index is used to map each element value to its index on the list Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Return Values: \u00b6 Name Type Description true struct HashListLibrary.List if the sub list is indexed ### setOwner function setOwner ( ) public setOwner set list owner param _owner owner address indexOf \u00b6 function indexOf ( struct HashListLibrary . List _self , bytes32 value ) public returns ( uint256 ) indexOf gets the index of a value in a list Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Return Values: \u00b6 Name Type Description value struct HashListLibrary.List index in list ### isIndexed function isIndexed ( struct HashListLibrary . List _self ) public returns ( bool ) isIndexed checks if the list is indexed Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Return Values: \u00b6 Name Type Description true struct HashListLibrary.List if the list is indexed ### all function all ( struct HashListLibrary . List _self ) public returns ( bytes32 []) all returns all list elements Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Return Values: \u00b6 Name Type Description all struct HashListLibrary.List list elements ### has function has ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) size returns the list size Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Return Values: \u00b6 Name Type Description true struct HashListLibrary.List if the value exists ### size function size ( struct HashListLibrary . List _self ) public returns ( uint256 ) size gets the list size Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Return Values: \u00b6 Name Type Description total struct HashListLibrary.List length of the list ### ownedBy function ownedBy ( struct HashListLibrary . List _self ) public returns ( address ) ownedBy gets the list owner Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Return Values: \u00b6 Name Type Description list struct HashListLibrary.List owner","title":"HashListLibrary"},{"location":"contracts/libraries/HashListLibrary/#functions","text":"","title":"Functions"},{"location":"contracts/libraries/HashListLibrary/#add","text":"function add ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) add index an element then add it to a list","title":"add"},{"location":"contracts/libraries/HashListLibrary/#parameters","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is a bytes32 value","title":"Parameters:"},{"location":"contracts/libraries/HashListLibrary/#return-values","text":"Name Type Description true struct HashListLibrary.List if value is added successfully ### add function add ( struct HashListLibrary . List _self , bytes32 [] values ) public returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays","title":"Return Values:"},{"location":"contracts/libraries/HashListLibrary/#parameters_1","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage values bytes32[] is an array of elements value","title":"Parameters:"},{"location":"contracts/libraries/HashListLibrary/#return-values_1","text":"Name Type Description true struct HashListLibrary.List if values are added successfully ### update function update ( struct HashListLibrary . List _self , bytes32 oldValue , bytes32 newValue ) public returns ( bool ) update the value with a new value and maintain indices","title":"Return Values:"},{"location":"contracts/libraries/HashListLibrary/#parameters_2","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage oldValue bytes32 is an element value in a list newValue bytes32 new value","title":"Parameters:"},{"location":"contracts/libraries/HashListLibrary/#return-values_2","text":"Name Type Description true struct HashListLibrary.List if value is updated successfully ### remove function remove ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) remove value from a list, updates indices, and list size","title":"Return Values:"},{"location":"contracts/libraries/HashListLibrary/#parameters_3","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is an element value in a list","title":"Parameters:"},{"location":"contracts/libraries/HashListLibrary/#return-values_3","text":"Name Type Description true struct HashListLibrary.List if value is removed successfully ### get function get ( struct HashListLibrary . List _self , uint256 index ) public returns ( bytes32 ) has value by index","title":"Return Values:"},{"location":"contracts/libraries/HashListLibrary/#parameters_4","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage index uint256 is where is value is stored in the list","title":"Parameters:"},{"location":"contracts/libraries/HashListLibrary/#return-values_4","text":"Name Type Description the struct HashListLibrary.List value if exists ### index function index ( struct HashListLibrary . List _self , uint256 from , uint256 to ) public returns ( bool ) index is used to map each element value to its index on the list","title":"Return Values:"},{"location":"contracts/libraries/HashListLibrary/#parameters_5","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing","title":"Parameters:"},{"location":"contracts/libraries/HashListLibrary/#return-values_5","text":"Name Type Description true struct HashListLibrary.List if the sub list is indexed ### setOwner function setOwner ( ) public setOwner set list owner param _owner owner address","title":"Return Values:"},{"location":"contracts/libraries/HashListLibrary/#indexof","text":"function indexOf ( struct HashListLibrary . List _self , bytes32 value ) public returns ( uint256 ) indexOf gets the index of a value in a list","title":"indexOf"},{"location":"contracts/libraries/HashListLibrary/#parameters_6","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list","title":"Parameters:"},{"location":"contracts/libraries/HashListLibrary/#return-values_6","text":"Name Type Description value struct HashListLibrary.List index in list ### isIndexed function isIndexed ( struct HashListLibrary . List _self ) public returns ( bool ) isIndexed checks if the list is indexed","title":"Return Values:"},{"location":"contracts/libraries/HashListLibrary/#parameters_7","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage","title":"Parameters:"},{"location":"contracts/libraries/HashListLibrary/#return-values_7","text":"Name Type Description true struct HashListLibrary.List if the list is indexed ### all function all ( struct HashListLibrary . List _self ) public returns ( bytes32 []) all returns all list elements","title":"Return Values:"},{"location":"contracts/libraries/HashListLibrary/#parameters_8","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage","title":"Parameters:"},{"location":"contracts/libraries/HashListLibrary/#return-values_8","text":"Name Type Description all struct HashListLibrary.List list elements ### has function has ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) size returns the list size","title":"Return Values:"},{"location":"contracts/libraries/HashListLibrary/#parameters_9","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list","title":"Parameters:"},{"location":"contracts/libraries/HashListLibrary/#return-values_9","text":"Name Type Description true struct HashListLibrary.List if the value exists ### size function size ( struct HashListLibrary . List _self ) public returns ( uint256 ) size gets the list size","title":"Return Values:"},{"location":"contracts/libraries/HashListLibrary/#parameters_10","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage","title":"Parameters:"},{"location":"contracts/libraries/HashListLibrary/#return-values_10","text":"Name Type Description total struct HashListLibrary.List length of the list ### ownedBy function ownedBy ( struct HashListLibrary . List _self ) public returns ( address ) ownedBy gets the list owner","title":"Return Values:"},{"location":"contracts/libraries/HashListLibrary/#parameters_11","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage","title":"Parameters:"},{"location":"contracts/libraries/HashListLibrary/#return-values_11","text":"Name Type Description list struct HashListLibrary.List owner","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/","text":"Implementation of the DID Registry. Functions \u00b6 initialize \u00b6 function initialize ( address _owner ) public DIDRegistry Initializer Initialize Ownable. Only on contract creation. Parameters: \u00b6 Name Type Description _owner address refers to the owner of the contract. setManager \u00b6 function setManager ( ) external Sets the manager role. Should be the TransferCondition contract address registerAttribute \u00b6 function registerAttribute ( bytes32 _didSeed , bytes32 _checksum , address [] _url ) public returns ( uint256 size ) Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Parameters: \u00b6 Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _url address[] refers to the attribute value, limited to 2048 bytes. Return Values: \u00b6 Name Type Description size bytes32 refers to the size of the registry after the register action. ### registerDID function registerDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , bytes32 _providers , string _activityId , _attributes ) public returns ( uint256 size ) Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Parameters: \u00b6 Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). The final DID will be calculated with the creator address using the hashDID function _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _providers bytes32 list of DID providers addresses _activityId string refers to activity _attributes refers to the provenance attributes Return Values: \u00b6 Name Type Description size bytes32 refers to the size of the registry after the register action. ### hashDID function hashDID ( bytes32 _didSeed , address _creator ) public returns ( bytes32 ) It generates a DID using as seed a bytes32 and the address of the DID creator Parameters: \u00b6 Name Type Description _didSeed bytes32 refers to DID Seed used as base to generate the final DID _creator address address of the creator of the DID Return Values: \u00b6 Name Type Description the bytes32 new DID created ### areRoyaltiesValid function areRoyaltiesValid ( bytes32 _did , uint256 [] _amounts , address [] _receivers ) public returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards Return Values: \u00b6 Name Type Description true bytes32 if the rewards distribution respect the original creator royalties ### wasGeneratedBy function wasGeneratedBy ( ) internal returns ( bool ) used \u00b6 function used ( ) public returns ( bool success ) wasDerivedFrom \u00b6 function wasDerivedFrom ( ) public returns ( bool success ) wasAssociatedWith \u00b6 function wasAssociatedWith ( ) public returns ( bool success ) actedOnBehalf \u00b6 function actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) public returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId) Parameters: \u00b6 Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Return Values: \u00b6 Name Type Description success bytes32 true if the action was properly registered ### addDIDProvider function addDIDProvider ( bytes32 _did , address _provider ) external addDIDProvider add new DID provider. it adds new DID provider to the providers list. A provider is any entity that can serve the registered asset Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address. removeDIDProvider \u00b6 function removeDIDProvider ( bytes32 _did , address _provider ) external removeDIDProvider delete an existing DID provider. Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address. addDIDProvenanceDelegate \u00b6 function addDIDProvenanceDelegate ( bytes32 _did , address _delegate ) public addDIDProvenanceDelegate add new DID provenance delegate. it adds new DID provenance delegate to the delegates list. A delegate is any entity that interact with the provenance entries of one DID Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegates's address. removeDIDProvenanceDelegate \u00b6 function removeDIDProvenanceDelegate ( bytes32 _did , address _delegate ) external removeDIDProvenanceDelegate delete an existing DID delegate. Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address. transferDIDOwnership \u00b6 function transferDIDOwnership ( bytes32 _did , address _newOwner ) external transferDIDOwnership transfer DID ownership Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address transferDIDOwnershipManaged \u00b6 function transferDIDOwnershipManaged ( address _did , bytes32 _newOwner ) external transferDIDOwnershipManaged transfer DID ownership Parameters: \u00b6 Name Type Description _did address refers to decentralized identifier (a bytes32 length ID) _newOwner bytes32 new owner address _transferDIDOwnership \u00b6 function _transferDIDOwnership ( ) internal grantPermission \u00b6 function grantPermission ( bytes32 _did , address _grantee ) external grantPermission grants access permission to grantee Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address revokePermission \u00b6 function revokePermission ( bytes32 _did , address _grantee ) external revokePermission revokes access permission from grantee Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address getPermission \u00b6 function getPermission ( bytes32 _did , address _grantee ) external returns ( bool ) getPermission gets access permission of a grantee Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Return Values: \u00b6 Name Type Description true bytes32 if grantee has access permission to a DID ### isDIDProvider function isDIDProvider ( bytes32 _did , address _provider ) public returns ( bool ) isDIDProvider check whether a given DID provider exists Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address. getDIDRegister \u00b6 function getDIDRegister ( bytes32 _did ) public returns ( address owner , bytes32 lastChecksum , string url , address lastUpdatedBy , uint256 blockNumberUpdated , address [] providers , uint256 nftSupply , uint256 mintCap , uint256 royalties ) Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Return Values: \u00b6 Name Type Description owner bytes32 the did owner lastChecksum url lastUpdatedBy blockNumberUpdated getBlockNumberUpdated \u00b6 function getBlockNumberUpdated ( bytes32 _did ) public returns ( uint256 blockNumberUpdated ) Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Return Values: \u00b6 Name Type Description blockNumberUpdated bytes32 last modified (update) block number of a DID. ### getDIDOwner function getDIDOwner ( bytes32 _did ) public returns ( address didOwner ) Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Return Values: \u00b6 Name Type Description didOwner bytes32 the address of the DID owner. ### getDIDRegistrySize function getDIDRegistrySize ( ) public returns ( uint256 size ) Return Values: \u00b6 Name Type Description size the length of the DID registry. ### getDIDRegisterIds function getDIDRegisterIds ( ) public returns ( bytes32 []) Return Values: \u00b6 Name Type Description the list of items in the DID registry. ### _grantPermission function _grantPermission ( bytes32 _did , address _grantee ) internal _grantPermission grants access permission to grantee Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address _revokePermission \u00b6 function _revokePermission ( bytes32 _did , address _grantee ) internal _revokePermission revokes access permission from grantee Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address _getPermission \u00b6 function _getPermission ( bytes32 _did , address _grantee ) internal returns ( bool ) _getPermission gets access permission of a grantee Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Return Values: \u00b6 Name Type Description true bytes32 if grantee has access permission to a DID ### getProvenanceEntry function getProvenanceEntry ( bytes32 _provId ) public returns ( bytes32 did , bytes32 relatedDid , address agentId , bytes32 activityId , address agentInvolvedId , uint8 method , address createdBy , uint256 blockNumberUpdated , bytes signature ) Fetch the complete provenance entry attributes Parameters: \u00b6 Name Type Description _provId bytes32 refers to the provenance identifier Return Values: \u00b6 Name Type Description did bytes32 relatedDid activityId agentInvolvedId createdBy blockNumberUpdated signature isDIDOwner \u00b6 function isDIDOwner ( address _address , bytes32 _did ) public returns ( bool ) isDIDOwner check whether a given address is owner for a DID Parameters: \u00b6 Name Type Description _address address user address. _did bytes32 refers to decentralized identifier (a bytes32 length ID). isOwnerProviderOrDelegate \u00b6 function isOwnerProviderOrDelegate ( bytes32 _did ) public returns ( bool ) isOwnerProviderOrDelegate check whether msg.sender is owner, provider or delegate for a DID given Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Return Values: \u00b6 Name Type Description boolean bytes32 true if yes ### isProvenanceDelegate function isProvenanceDelegate ( bytes32 _did , address _delegate ) public returns ( bool ) isProvenanceDelegate check whether a given DID delegate exists Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address. Return Values: \u00b6 Name Type Description boolean bytes32 true if yes ### getProvenanceOwner function getProvenanceOwner ( bytes32 _did ) public returns ( address provenanceOwner ) Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Return Values: \u00b6 Name Type Description provenanceOwner bytes32 the address of the Provenance owner. ## Events ### DIDAttributeRegistered event DIDAttributeRegistered ( ) DID Events DIDProviderRemoved \u00b6 event DIDProviderRemoved ( ) DIDProviderAdded \u00b6 event DIDProviderAdded ( ) DIDOwnershipTransferred \u00b6 event DIDOwnershipTransferred ( ) DIDPermissionGranted \u00b6 event DIDPermissionGranted ( ) DIDPermissionRevoked \u00b6 event DIDPermissionRevoked ( ) DIDProvenanceDelegateRemoved \u00b6 event DIDProvenanceDelegateRemoved ( ) DIDProvenanceDelegateAdded \u00b6 event DIDProvenanceDelegateAdded ( )","title":"DIDFactory"},{"location":"contracts/registry/DIDFactory/#functions","text":"","title":"Functions"},{"location":"contracts/registry/DIDFactory/#initialize","text":"function initialize ( address _owner ) public DIDRegistry Initializer Initialize Ownable. Only on contract creation.","title":"initialize"},{"location":"contracts/registry/DIDFactory/#parameters","text":"Name Type Description _owner address refers to the owner of the contract.","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#setmanager","text":"function setManager ( ) external Sets the manager role. Should be the TransferCondition contract address","title":"setManager"},{"location":"contracts/registry/DIDFactory/#registerattribute","text":"function registerAttribute ( bytes32 _didSeed , bytes32 _checksum , address [] _url ) public returns ( uint256 size ) Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info.","title":"registerAttribute"},{"location":"contracts/registry/DIDFactory/#parameters_1","text":"Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _url address[] refers to the attribute value, limited to 2048 bytes.","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#return-values","text":"Name Type Description size bytes32 refers to the size of the registry after the register action. ### registerDID function registerDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , bytes32 _providers , string _activityId , _attributes ) public returns ( uint256 size ) Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info.","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#parameters_2","text":"Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). The final DID will be calculated with the creator address using the hashDID function _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _providers bytes32 list of DID providers addresses _activityId string refers to activity _attributes refers to the provenance attributes","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#return-values_1","text":"Name Type Description size bytes32 refers to the size of the registry after the register action. ### hashDID function hashDID ( bytes32 _didSeed , address _creator ) public returns ( bytes32 ) It generates a DID using as seed a bytes32 and the address of the DID creator","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#parameters_3","text":"Name Type Description _didSeed bytes32 refers to DID Seed used as base to generate the final DID _creator address address of the creator of the DID","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#return-values_2","text":"Name Type Description the bytes32 new DID created ### areRoyaltiesValid function areRoyaltiesValid ( bytes32 _did , uint256 [] _amounts , address [] _receivers ) public returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#parameters_4","text":"Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#return-values_3","text":"Name Type Description true bytes32 if the rewards distribution respect the original creator royalties ### wasGeneratedBy function wasGeneratedBy ( ) internal returns ( bool )","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#used","text":"function used ( ) public returns ( bool success )","title":"used"},{"location":"contracts/registry/DIDFactory/#wasderivedfrom","text":"function wasDerivedFrom ( ) public returns ( bool success )","title":"wasDerivedFrom"},{"location":"contracts/registry/DIDFactory/#wasassociatedwith","text":"function wasAssociatedWith ( ) public returns ( bool success )","title":"wasAssociatedWith"},{"location":"contracts/registry/DIDFactory/#actedonbehalf","text":"function actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) public returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId)","title":"actedOnBehalf"},{"location":"contracts/registry/DIDFactory/#parameters_5","text":"Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#return-values_4","text":"Name Type Description success bytes32 true if the action was properly registered ### addDIDProvider function addDIDProvider ( bytes32 _did , address _provider ) external addDIDProvider add new DID provider. it adds new DID provider to the providers list. A provider is any entity that can serve the registered asset","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#parameters_6","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address.","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#removedidprovider","text":"function removeDIDProvider ( bytes32 _did , address _provider ) external removeDIDProvider delete an existing DID provider.","title":"removeDIDProvider"},{"location":"contracts/registry/DIDFactory/#parameters_7","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address.","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#adddidprovenancedelegate","text":"function addDIDProvenanceDelegate ( bytes32 _did , address _delegate ) public addDIDProvenanceDelegate add new DID provenance delegate. it adds new DID provenance delegate to the delegates list. A delegate is any entity that interact with the provenance entries of one DID","title":"addDIDProvenanceDelegate"},{"location":"contracts/registry/DIDFactory/#parameters_8","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegates's address.","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#removedidprovenancedelegate","text":"function removeDIDProvenanceDelegate ( bytes32 _did , address _delegate ) external removeDIDProvenanceDelegate delete an existing DID delegate.","title":"removeDIDProvenanceDelegate"},{"location":"contracts/registry/DIDFactory/#parameters_9","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address.","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#transferdidownership","text":"function transferDIDOwnership ( bytes32 _did , address _newOwner ) external transferDIDOwnership transfer DID ownership","title":"transferDIDOwnership"},{"location":"contracts/registry/DIDFactory/#parameters_10","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#transferdidownershipmanaged","text":"function transferDIDOwnershipManaged ( address _did , bytes32 _newOwner ) external transferDIDOwnershipManaged transfer DID ownership","title":"transferDIDOwnershipManaged"},{"location":"contracts/registry/DIDFactory/#parameters_11","text":"Name Type Description _did address refers to decentralized identifier (a bytes32 length ID) _newOwner bytes32 new owner address","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#_transferdidownership","text":"function _transferDIDOwnership ( ) internal","title":"_transferDIDOwnership"},{"location":"contracts/registry/DIDFactory/#grantpermission","text":"function grantPermission ( bytes32 _did , address _grantee ) external grantPermission grants access permission to grantee","title":"grantPermission"},{"location":"contracts/registry/DIDFactory/#parameters_12","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#revokepermission","text":"function revokePermission ( bytes32 _did , address _grantee ) external revokePermission revokes access permission from grantee","title":"revokePermission"},{"location":"contracts/registry/DIDFactory/#parameters_13","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#getpermission","text":"function getPermission ( bytes32 _did , address _grantee ) external returns ( bool ) getPermission gets access permission of a grantee","title":"getPermission"},{"location":"contracts/registry/DIDFactory/#parameters_14","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#return-values_5","text":"Name Type Description true bytes32 if grantee has access permission to a DID ### isDIDProvider function isDIDProvider ( bytes32 _did , address _provider ) public returns ( bool ) isDIDProvider check whether a given DID provider exists","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#parameters_15","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address.","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#getdidregister","text":"function getDIDRegister ( bytes32 _did ) public returns ( address owner , bytes32 lastChecksum , string url , address lastUpdatedBy , uint256 blockNumberUpdated , address [] providers , uint256 nftSupply , uint256 mintCap , uint256 royalties )","title":"getDIDRegister"},{"location":"contracts/registry/DIDFactory/#parameters_16","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID).","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#return-values_6","text":"Name Type Description owner bytes32 the did owner lastChecksum url lastUpdatedBy blockNumberUpdated","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#getblocknumberupdated","text":"function getBlockNumberUpdated ( bytes32 _did ) public returns ( uint256 blockNumberUpdated )","title":"getBlockNumberUpdated"},{"location":"contracts/registry/DIDFactory/#parameters_17","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID).","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#return-values_7","text":"Name Type Description blockNumberUpdated bytes32 last modified (update) block number of a DID. ### getDIDOwner function getDIDOwner ( bytes32 _did ) public returns ( address didOwner )","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#parameters_18","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID).","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#return-values_8","text":"Name Type Description didOwner bytes32 the address of the DID owner. ### getDIDRegistrySize function getDIDRegistrySize ( ) public returns ( uint256 size )","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#return-values_9","text":"Name Type Description size the length of the DID registry. ### getDIDRegisterIds function getDIDRegisterIds ( ) public returns ( bytes32 [])","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#return-values_10","text":"Name Type Description the list of items in the DID registry. ### _grantPermission function _grantPermission ( bytes32 _did , address _grantee ) internal _grantPermission grants access permission to grantee","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#parameters_19","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#_revokepermission","text":"function _revokePermission ( bytes32 _did , address _grantee ) internal _revokePermission revokes access permission from grantee","title":"_revokePermission"},{"location":"contracts/registry/DIDFactory/#parameters_20","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#_getpermission","text":"function _getPermission ( bytes32 _did , address _grantee ) internal returns ( bool ) _getPermission gets access permission of a grantee","title":"_getPermission"},{"location":"contracts/registry/DIDFactory/#parameters_21","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#return-values_11","text":"Name Type Description true bytes32 if grantee has access permission to a DID ### getProvenanceEntry function getProvenanceEntry ( bytes32 _provId ) public returns ( bytes32 did , bytes32 relatedDid , address agentId , bytes32 activityId , address agentInvolvedId , uint8 method , address createdBy , uint256 blockNumberUpdated , bytes signature ) Fetch the complete provenance entry attributes","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#parameters_22","text":"Name Type Description _provId bytes32 refers to the provenance identifier","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#return-values_12","text":"Name Type Description did bytes32 relatedDid activityId agentInvolvedId createdBy blockNumberUpdated signature","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#isdidowner","text":"function isDIDOwner ( address _address , bytes32 _did ) public returns ( bool ) isDIDOwner check whether a given address is owner for a DID","title":"isDIDOwner"},{"location":"contracts/registry/DIDFactory/#parameters_23","text":"Name Type Description _address address user address. _did bytes32 refers to decentralized identifier (a bytes32 length ID).","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#isownerproviderordelegate","text":"function isOwnerProviderOrDelegate ( bytes32 _did ) public returns ( bool ) isOwnerProviderOrDelegate check whether msg.sender is owner, provider or delegate for a DID given","title":"isOwnerProviderOrDelegate"},{"location":"contracts/registry/DIDFactory/#parameters_24","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID).","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#return-values_13","text":"Name Type Description boolean bytes32 true if yes ### isProvenanceDelegate function isProvenanceDelegate ( bytes32 _did , address _delegate ) public returns ( bool ) isProvenanceDelegate check whether a given DID delegate exists","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#parameters_25","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address.","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#return-values_14","text":"Name Type Description boolean bytes32 true if yes ### getProvenanceOwner function getProvenanceOwner ( bytes32 _did ) public returns ( address provenanceOwner )","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#parameters_26","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID).","title":"Parameters:"},{"location":"contracts/registry/DIDFactory/#return-values_15","text":"Name Type Description provenanceOwner bytes32 the address of the Provenance owner. ## Events ### DIDAttributeRegistered event DIDAttributeRegistered ( ) DID Events","title":"Return Values:"},{"location":"contracts/registry/DIDFactory/#didproviderremoved","text":"event DIDProviderRemoved ( )","title":"DIDProviderRemoved"},{"location":"contracts/registry/DIDFactory/#didprovideradded","text":"event DIDProviderAdded ( )","title":"DIDProviderAdded"},{"location":"contracts/registry/DIDFactory/#didownershiptransferred","text":"event DIDOwnershipTransferred ( )","title":"DIDOwnershipTransferred"},{"location":"contracts/registry/DIDFactory/#didpermissiongranted","text":"event DIDPermissionGranted ( )","title":"DIDPermissionGranted"},{"location":"contracts/registry/DIDFactory/#didpermissionrevoked","text":"event DIDPermissionRevoked ( )","title":"DIDPermissionRevoked"},{"location":"contracts/registry/DIDFactory/#didprovenancedelegateremoved","text":"event DIDProvenanceDelegateRemoved ( )","title":"DIDProvenanceDelegateRemoved"},{"location":"contracts/registry/DIDFactory/#didprovenancedelegateadded","text":"event DIDProvenanceDelegateAdded ( )","title":"DIDProvenanceDelegateAdded"},{"location":"contracts/registry/DIDRegistry/","text":"Implementation of a Mintable DID Registry. Functions \u00b6 initialize \u00b6 function initialize ( address _owner ) public DIDRegistry Initializer Initialize Ownable. Only on contract creation. Parameters: \u00b6 Name Type Description _owner address refers to the owner of the contract. registerMintableDID \u00b6 function registerMintableDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint256 _cap , uint8 _royalties , bytes32 _activityId , string _attributes ) public returns ( uint256 size ) Register a Mintable DID. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Parameters: \u00b6 Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Return Values: \u00b6 Name Type Description size bytes32 refers to the size of the registry after the register action. ### enableAndMintDidNft function enableAndMintDidNft ( bytes32 _did , uint256 _cap , uint8 _royalties , bool _preMint ) public returns ( bool success ) enableDidNft creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _preMint bool if is true mint directly the amount capped tokens and lock in the _lockAddress mint \u00b6 function mint ( bytes32 _did , uint256 _amount ) public Mints a NFT associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can mint NFTs associated to the DID Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to mint burn \u00b6 function burn ( bytes32 _did , uint256 _amount ) public Burns NFTs associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can burn NFTs associated to the DID Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to burn","title":"DIDRegistry"},{"location":"contracts/registry/DIDRegistry/#functions","text":"","title":"Functions"},{"location":"contracts/registry/DIDRegistry/#initialize","text":"function initialize ( address _owner ) public DIDRegistry Initializer Initialize Ownable. Only on contract creation.","title":"initialize"},{"location":"contracts/registry/DIDRegistry/#parameters","text":"Name Type Description _owner address refers to the owner of the contract.","title":"Parameters:"},{"location":"contracts/registry/DIDRegistry/#registermintabledid","text":"function registerMintableDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint256 _cap , uint8 _royalties , bytes32 _activityId , string _attributes ) public returns ( uint256 size ) Register a Mintable DID. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info.","title":"registerMintableDID"},{"location":"contracts/registry/DIDRegistry/#parameters_1","text":"Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _activityId bytes32 refers to activity _attributes string refers to the provenance attributes","title":"Parameters:"},{"location":"contracts/registry/DIDRegistry/#return-values","text":"Name Type Description size bytes32 refers to the size of the registry after the register action. ### enableAndMintDidNft function enableAndMintDidNft ( bytes32 _did , uint256 _cap , uint8 _royalties , bool _preMint ) public returns ( bool success ) enableDidNft creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration","title":"Return Values:"},{"location":"contracts/registry/DIDRegistry/#parameters_2","text":"Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _preMint bool if is true mint directly the amount capped tokens and lock in the _lockAddress","title":"Parameters:"},{"location":"contracts/registry/DIDRegistry/#mint","text":"function mint ( bytes32 _did , uint256 _amount ) public Mints a NFT associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can mint NFTs associated to the DID","title":"mint"},{"location":"contracts/registry/DIDRegistry/#parameters_3","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to mint","title":"Parameters:"},{"location":"contracts/registry/DIDRegistry/#burn","text":"function burn ( bytes32 _did , uint256 _amount ) public Burns NFTs associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can burn NFTs associated to the DID","title":"burn"},{"location":"contracts/registry/DIDRegistry/#parameters_4","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to burn","title":"Parameters:"},{"location":"contracts/registry/DIDRegistryLibrary/","text":"All function calls are currently implemented without side effects Functions \u00b6 update \u00b6 function update ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , bytes32 _checksum , string _url ) external returns ( uint256 size ) update the DID store access modifiers and storage pointer should be implemented in DIDRegistry Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _checksum bytes32 includes a one-way HASH calculated using the DDO content _url string includes the url resolving to the DID Document (DDO) initializeNftConfig \u00b6 function initializeNftConfig ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 _cap , uint8 _royalties ) internal initializeNftConfig creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market The royalties in secondary market for the creator should be between 0% >= x < 100% areRoyaltiesValid \u00b6 function areRoyaltiesValid ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 [] _amounts , address [] _receivers ) internal returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards Return Values: \u00b6 Name Type Description true struct DIDRegistryLibrary.DIDRegisterList if the rewards distribution respect the original creator royalties ### addProvider function addProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address provider ) internal addProvider add provider to DID registry update the DID registry providers list by adding a new provider Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address removeProvider \u00b6 function removeProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) internal returns ( bool ) removeProvider remove provider from DID registry update the DID registry providers list by removing an existing provider Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address updateDIDOwner \u00b6 function updateDIDOwner ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _newOwner ) internal updateDIDOwner transfer DID ownership to a new owner Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _newOwner address the new DID owner address isProvider \u00b6 function isProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) public returns ( bool ) isProvider check whether DID provider exists Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address Return Values: \u00b6 Name Type Description true struct DIDRegistryLibrary.DIDRegisterList if the provider already exists ### addDelegate function addDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address delegate ) internal addDelegate add delegate to DID registry update the DID registry delegates list by adding a new delegate Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address removeDelegate \u00b6 function removeDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) internal returns ( bool ) removeDelegate remove delegate from DID registry update the DID registry delegates list by removing an existing delegate Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address isDelegate \u00b6 function isDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) public returns ( bool ) isDelegate check whether DID delegate exists Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address Return Values: \u00b6 Name Type Description true struct DIDRegistryLibrary.DIDRegisterList if the delegate already exists","title":"DIDRegistryLibrary"},{"location":"contracts/registry/DIDRegistryLibrary/#functions","text":"","title":"Functions"},{"location":"contracts/registry/DIDRegistryLibrary/#update","text":"function update ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , bytes32 _checksum , string _url ) external returns ( uint256 size ) update the DID store access modifiers and storage pointer should be implemented in DIDRegistry","title":"update"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _checksum bytes32 includes a one-way HASH calculated using the DDO content _url string includes the url resolving to the DID Document (DDO)","title":"Parameters:"},{"location":"contracts/registry/DIDRegistryLibrary/#initializenftconfig","text":"function initializeNftConfig ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 _cap , uint8 _royalties ) internal initializeNftConfig creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration","title":"initializeNftConfig"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_1","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market The royalties in secondary market for the creator should be between 0% >= x < 100%","title":"Parameters:"},{"location":"contracts/registry/DIDRegistryLibrary/#areroyaltiesvalid","text":"function areRoyaltiesValid ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 [] _amounts , address [] _receivers ) internal returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly","title":"areRoyaltiesValid"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_2","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards","title":"Parameters:"},{"location":"contracts/registry/DIDRegistryLibrary/#return-values","text":"Name Type Description true struct DIDRegistryLibrary.DIDRegisterList if the rewards distribution respect the original creator royalties ### addProvider function addProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address provider ) internal addProvider add provider to DID registry update the DID registry providers list by adding a new provider","title":"Return Values:"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_3","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address","title":"Parameters:"},{"location":"contracts/registry/DIDRegistryLibrary/#removeprovider","text":"function removeProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) internal returns ( bool ) removeProvider remove provider from DID registry update the DID registry providers list by removing an existing provider","title":"removeProvider"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_4","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address","title":"Parameters:"},{"location":"contracts/registry/DIDRegistryLibrary/#updatedidowner","text":"function updateDIDOwner ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _newOwner ) internal updateDIDOwner transfer DID ownership to a new owner","title":"updateDIDOwner"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_5","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _newOwner address the new DID owner address","title":"Parameters:"},{"location":"contracts/registry/DIDRegistryLibrary/#isprovider","text":"function isProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) public returns ( bool ) isProvider check whether DID provider exists","title":"isProvider"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_6","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address","title":"Parameters:"},{"location":"contracts/registry/DIDRegistryLibrary/#return-values_1","text":"Name Type Description true struct DIDRegistryLibrary.DIDRegisterList if the provider already exists ### addDelegate function addDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address delegate ) internal addDelegate add delegate to DID registry update the DID registry delegates list by adding a new delegate","title":"Return Values:"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_7","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address","title":"Parameters:"},{"location":"contracts/registry/DIDRegistryLibrary/#removedelegate","text":"function removeDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) internal returns ( bool ) removeDelegate remove delegate from DID registry update the DID registry delegates list by removing an existing delegate","title":"removeDelegate"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_8","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address","title":"Parameters:"},{"location":"contracts/registry/DIDRegistryLibrary/#isdelegate","text":"function isDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) public returns ( bool ) isDelegate check whether DID delegate exists","title":"isDelegate"},{"location":"contracts/registry/DIDRegistryLibrary/#parameters_9","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address","title":"Parameters:"},{"location":"contracts/registry/DIDRegistryLibrary/#return-values_2","text":"Name Type Description true struct DIDRegistryLibrary.DIDRegisterList if the delegate already exists","title":"Return Values:"},{"location":"contracts/registry/ProvenanceRegistry/","text":"All function calls are currently implemented without side effects Functions \u00b6 __ProvenanceRegistry_init \u00b6 function __ProvenanceRegistry_init ( ) internal __ProvenanceRegistry_init_unchained \u00b6 function __ProvenanceRegistry_init_unchained ( ) internal createProvenanceEntry \u00b6 function createProvenanceEntry ( bytes32 _provId , bytes32 _did , bytes32 _relatedDid , address _agentId , bytes32 _activityId , address _agentInvolvedId , enum ProvenanceRegistry . ProvenanceMethod _method , address _createdBy , bytes _signatureDelegate ) internal returns ( bool ) create an event in the Provenance store access modifiers and storage pointer should be implemented in ProvenanceRegistry Parameters: \u00b6 Name Type Description _provId bytes32 refers to provenance event identifier _did bytes32 refers to decentralized identifier (a byte32 length ID) _relatedDid bytes32 refers to decentralized identifier (a byte32 length ID) of a related entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _agentInvolvedId address refers to address of the agent involved with the provenance record _method enum ProvenanceRegistry.ProvenanceMethod refers to the W3C Provenance method _createdBy address refers to address of the agent triggering the activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _wasGeneratedBy \u00b6 function _wasGeneratedBy ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool ) Implements the W3C PROV Generation action Parameters: \u00b6 Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Return Values: \u00b6 Name Type Description the bytes32 number of the new provenance size ### _used function _used ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes _signatureUsing , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Usage action Parameters: \u00b6 Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _signatureUsing bytes refers to the digital signature provided by the agent using the _did _attributes string refers to the provenance attributes Return Values: \u00b6 Name Type Description success bytes32 true if the action was properly registered ### _wasDerivedFrom function _wasDerivedFrom ( bytes32 _provId , bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Derivation action Parameters: \u00b6 Name Type Description _provId bytes32 unique identifier referring to the provenance entry _newEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _usedEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity used to derive the new did _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Return Values: \u00b6 Name Type Description success bytes32 true if the action was properly registered ### _wasAssociatedWith function _wasAssociatedWith ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Association action Parameters: \u00b6 Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Return Values: \u00b6 Name Type Description success bytes32 true if the action was properly registered ### _actedOnBehalf function _actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId) Parameters: \u00b6 Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Return Values: \u00b6 Name Type Description success bytes32 true if the action was properly registered ## Events ### ProvenanceAttributeRegistered event ProvenanceAttributeRegistered ( ) Provenance Events WasGeneratedBy \u00b6 event WasGeneratedBy ( ) Used \u00b6 event Used ( ) WasDerivedFrom \u00b6 event WasDerivedFrom ( ) WasAssociatedWith \u00b6 event WasAssociatedWith ( ) ActedOnBehalf \u00b6 event ActedOnBehalf ( )","title":"ProvenanceRegistry"},{"location":"contracts/registry/ProvenanceRegistry/#functions","text":"","title":"Functions"},{"location":"contracts/registry/ProvenanceRegistry/#__provenanceregistry_init","text":"function __ProvenanceRegistry_init ( ) internal","title":"__ProvenanceRegistry_init"},{"location":"contracts/registry/ProvenanceRegistry/#__provenanceregistry_init_unchained","text":"function __ProvenanceRegistry_init_unchained ( ) internal","title":"__ProvenanceRegistry_init_unchained"},{"location":"contracts/registry/ProvenanceRegistry/#createprovenanceentry","text":"function createProvenanceEntry ( bytes32 _provId , bytes32 _did , bytes32 _relatedDid , address _agentId , bytes32 _activityId , address _agentInvolvedId , enum ProvenanceRegistry . ProvenanceMethod _method , address _createdBy , bytes _signatureDelegate ) internal returns ( bool ) create an event in the Provenance store access modifiers and storage pointer should be implemented in ProvenanceRegistry","title":"createProvenanceEntry"},{"location":"contracts/registry/ProvenanceRegistry/#parameters","text":"Name Type Description _provId bytes32 refers to provenance event identifier _did bytes32 refers to decentralized identifier (a byte32 length ID) _relatedDid bytes32 refers to decentralized identifier (a byte32 length ID) of a related entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _agentInvolvedId address refers to address of the agent involved with the provenance record _method enum ProvenanceRegistry.ProvenanceMethod refers to the W3C Provenance method _createdBy address refers to address of the agent triggering the activity _signatureDelegate bytes refers to the digital signature provided by the did delegate.","title":"Parameters:"},{"location":"contracts/registry/ProvenanceRegistry/#_wasgeneratedby","text":"function _wasGeneratedBy ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool ) Implements the W3C PROV Generation action","title":"_wasGeneratedBy"},{"location":"contracts/registry/ProvenanceRegistry/#parameters_1","text":"Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes","title":"Parameters:"},{"location":"contracts/registry/ProvenanceRegistry/#return-values","text":"Name Type Description the bytes32 number of the new provenance size ### _used function _used ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes _signatureUsing , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Usage action","title":"Return Values:"},{"location":"contracts/registry/ProvenanceRegistry/#parameters_2","text":"Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _signatureUsing bytes refers to the digital signature provided by the agent using the _did _attributes string refers to the provenance attributes","title":"Parameters:"},{"location":"contracts/registry/ProvenanceRegistry/#return-values_1","text":"Name Type Description success bytes32 true if the action was properly registered ### _wasDerivedFrom function _wasDerivedFrom ( bytes32 _provId , bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Derivation action","title":"Return Values:"},{"location":"contracts/registry/ProvenanceRegistry/#parameters_3","text":"Name Type Description _provId bytes32 unique identifier referring to the provenance entry _newEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _usedEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity used to derive the new did _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes","title":"Parameters:"},{"location":"contracts/registry/ProvenanceRegistry/#return-values_2","text":"Name Type Description success bytes32 true if the action was properly registered ### _wasAssociatedWith function _wasAssociatedWith ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Association action","title":"Return Values:"},{"location":"contracts/registry/ProvenanceRegistry/#parameters_4","text":"Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes","title":"Parameters:"},{"location":"contracts/registry/ProvenanceRegistry/#return-values_3","text":"Name Type Description success bytes32 true if the action was properly registered ### _actedOnBehalf function _actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId)","title":"Return Values:"},{"location":"contracts/registry/ProvenanceRegistry/#parameters_5","text":"Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes","title":"Parameters:"},{"location":"contracts/registry/ProvenanceRegistry/#return-values_4","text":"Name Type Description success bytes32 true if the action was properly registered ## Events ### ProvenanceAttributeRegistered event ProvenanceAttributeRegistered ( ) Provenance Events","title":"Return Values:"},{"location":"contracts/registry/ProvenanceRegistry/#wasgeneratedby","text":"event WasGeneratedBy ( )","title":"WasGeneratedBy"},{"location":"contracts/registry/ProvenanceRegistry/#used","text":"event Used ( )","title":"Used"},{"location":"contracts/registry/ProvenanceRegistry/#wasderivedfrom","text":"event WasDerivedFrom ( )","title":"WasDerivedFrom"},{"location":"contracts/registry/ProvenanceRegistry/#wasassociatedwith","text":"event WasAssociatedWith ( )","title":"WasAssociatedWith"},{"location":"contracts/registry/ProvenanceRegistry/#actedonbehalf","text":"event ActedOnBehalf ( )","title":"ActedOnBehalf"},{"location":"contracts/templates/AccessProofTemplate/","text":"Implementation of Access Agreement Template Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address","title":"AccessProofTemplate"},{"location":"contracts/templates/AccessProofTemplate/#functions","text":"","title":"Functions"},{"location":"contracts/templates/AccessProofTemplate/#initialize","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions.","title":"initialize"},{"location":"contracts/templates/AccessProofTemplate/#parameters","text":"Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address","title":"Parameters:"},{"location":"contracts/templates/AccessTemplate/","text":"Implementation of Access Agreement Template Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an on-chain SEA. The template is a composite of three basic conditions. Once the agreement is created, the consumer will lock an amount of tokens (as listed in the DID document - off-chain metadata) to the the lock reward contract which in turn will fire an event. ON the other hand the provider is listening to all the emitted events, the provider will catch the event and grant permissions to the consumer through secret store contract, the consumer now is able to download the data set by asking the off-chain component of secret store to decrypt the DID and encrypt it using the consumer's public key. Then the secret store will provide an on-chain proof that the consumer had access to the data set. Finally, the provider can call the escrow reward condition in order to release the payment. Every condition has a time window (time lock and time out). This implies that if the provider didn't grant the access to the consumer through secret store within this time window, the consumer can ask for refund. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address","title":"AccessTemplate"},{"location":"contracts/templates/AccessTemplate/#functions","text":"","title":"Functions"},{"location":"contracts/templates/AccessTemplate/#initialize","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions.","title":"initialize"},{"location":"contracts/templates/AccessTemplate/#parameters","text":"Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address","title":"Parameters:"},{"location":"contracts/templates/AgreementTemplate/","text":"Implementation of Agreement Template Agreement template is a reference template where it has the ability to create agreements from whitelisted template Functions \u00b6 createAgreement \u00b6 function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public returns ( uint256 size ) createAgreement create new agreement Parameters: \u00b6 Name Type Description _id bytes32 agreement unique identifier _did bytes32 refers to decentralized identifier (a bytes32 length ID). _conditionIds bytes32[] list of condition identifiers _timeLocks uint256[] list of time locks, each time lock will be assigned to the same condition that has the same index _timeOuts uint256[] list of time outs, each time out will be assigned to the same condition that has the same index Return Values: \u00b6 Name Type Description size bytes32 the index of the created agreement ### getConditionTypes function getConditionTypes ( ) public returns ( address []) getConditionTypes gets the conditions addresses list for the current template returns list of condition contracts addresses Return Values: \u00b6 Name Type Description list of conditions contract addresses","title":"AgreementTemplate"},{"location":"contracts/templates/AgreementTemplate/#functions","text":"","title":"Functions"},{"location":"contracts/templates/AgreementTemplate/#createagreement","text":"function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public returns ( uint256 size ) createAgreement create new agreement","title":"createAgreement"},{"location":"contracts/templates/AgreementTemplate/#parameters","text":"Name Type Description _id bytes32 agreement unique identifier _did bytes32 refers to decentralized identifier (a bytes32 length ID). _conditionIds bytes32[] list of condition identifiers _timeLocks uint256[] list of time locks, each time lock will be assigned to the same condition that has the same index _timeOuts uint256[] list of time outs, each time out will be assigned to the same condition that has the same index","title":"Parameters:"},{"location":"contracts/templates/AgreementTemplate/#return-values","text":"Name Type Description size bytes32 the index of the created agreement ### getConditionTypes function getConditionTypes ( ) public returns ( address []) getConditionTypes gets the conditions addresses list for the current template returns list of condition contracts addresses","title":"Return Values:"},{"location":"contracts/templates/AgreementTemplate/#return-values_1","text":"Name Type Description list of conditions contract addresses","title":"Return Values:"},{"location":"contracts/templates/BaseEscrowTemplate/","text":"Functions \u00b6 createAgreement \u00b6 function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer ) public returns ( uint256 size ) createAgreement creates agreements through agreement template this function initializes the agreement by setting the DID, conditions ID, timeouts, time locks and the consumer address. The DID provider/owner is automatically detected by the DID Registry Parameters: \u00b6 Name Type Description _id bytes32 SEA agreement unique identifier _did bytes32 Decentralized Identifier (DID) _conditionIds bytes32[] conditions ID associated with the condition types _timeLocks uint256[] the starting point of the time window ,time lock is in block number not seconds _timeOuts uint256[] the ending point of the time window ,time lock is in block number not seconds _accessConsumer address consumer address Return Values: \u00b6 Name Type Description size bytes32 the agreement index ### getAgreementData function getAgreementData ( bytes32 _id ) external returns ( address accessConsumer , address accessProvider ) getAgreementData return the agreement Data Parameters: \u00b6 Name Type Description _id bytes32 SEA agreement unique identifier Return Values: \u00b6 Name Type Description accessConsumer bytes32 the agreement consumer accessProvider the provider addresses ## Events ### AgreementCreated event AgreementCreated ( )","title":"BaseEscrowTemplate"},{"location":"contracts/templates/BaseEscrowTemplate/#functions","text":"","title":"Functions"},{"location":"contracts/templates/BaseEscrowTemplate/#createagreement","text":"function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer ) public returns ( uint256 size ) createAgreement creates agreements through agreement template this function initializes the agreement by setting the DID, conditions ID, timeouts, time locks and the consumer address. The DID provider/owner is automatically detected by the DID Registry","title":"createAgreement"},{"location":"contracts/templates/BaseEscrowTemplate/#parameters","text":"Name Type Description _id bytes32 SEA agreement unique identifier _did bytes32 Decentralized Identifier (DID) _conditionIds bytes32[] conditions ID associated with the condition types _timeLocks uint256[] the starting point of the time window ,time lock is in block number not seconds _timeOuts uint256[] the ending point of the time window ,time lock is in block number not seconds _accessConsumer address consumer address","title":"Parameters:"},{"location":"contracts/templates/BaseEscrowTemplate/#return-values","text":"Name Type Description size bytes32 the agreement index ### getAgreementData function getAgreementData ( bytes32 _id ) external returns ( address accessConsumer , address accessProvider ) getAgreementData return the agreement Data","title":"Return Values:"},{"location":"contracts/templates/BaseEscrowTemplate/#parameters_1","text":"Name Type Description _id bytes32 SEA agreement unique identifier","title":"Parameters:"},{"location":"contracts/templates/BaseEscrowTemplate/#return-values_1","text":"Name Type Description accessConsumer bytes32 the agreement consumer accessProvider the provider addresses ## Events ### AgreementCreated event AgreementCreated ( )","title":"Return Values:"},{"location":"contracts/templates/DIDSalesTemplate/","text":"Implementation of DID Sales Template The DID Sales template supports an scenario where an Asset owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing an Asset owner to get transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer DID Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the ownership transfer of an asset from the current owner for a specific DID. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockConditionAddress address lock reward condition contract address _transferConditionAddress address transfer ownership condition contract address _escrowPaymentAddress address payable escrow reward condition contract address","title":"DIDSalesTemplate"},{"location":"contracts/templates/DIDSalesTemplate/#functions","text":"","title":"Functions"},{"location":"contracts/templates/DIDSalesTemplate/#initialize","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions.","title":"initialize"},{"location":"contracts/templates/DIDSalesTemplate/#parameters","text":"Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockConditionAddress address lock reward condition contract address _transferConditionAddress address transfer ownership condition contract address _escrowPaymentAddress address payable escrow reward condition contract address","title":"Parameters:"},{"location":"contracts/templates/DynamicAccessTemplate/","text":"Implementation of Agreement Template This is a dynamic template that allows to setup flexible conditions depending on the use case. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address addTemplateCondition \u00b6 function addTemplateCondition ( address _conditionAddress ) external returns ( uint256 length ) addTemplateCondition adds a new condition to the template Parameters: \u00b6 Name Type Description _conditionAddress address condition contract address Return Values: \u00b6 Name Type Description length address conditionTypes array size ### removeLastTemplateCondition function removeLastTemplateCondition ( ) external returns ( address []) removeLastTemplateCondition removes last condition added to the template Return Values: \u00b6 Name Type Description conditionTypes existing in the array","title":"DynamicAccessTemplate"},{"location":"contracts/templates/DynamicAccessTemplate/#functions","text":"","title":"Functions"},{"location":"contracts/templates/DynamicAccessTemplate/#initialize","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions.","title":"initialize"},{"location":"contracts/templates/DynamicAccessTemplate/#parameters","text":"Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address","title":"Parameters:"},{"location":"contracts/templates/DynamicAccessTemplate/#addtemplatecondition","text":"function addTemplateCondition ( address _conditionAddress ) external returns ( uint256 length ) addTemplateCondition adds a new condition to the template","title":"addTemplateCondition"},{"location":"contracts/templates/DynamicAccessTemplate/#parameters_1","text":"Name Type Description _conditionAddress address condition contract address","title":"Parameters:"},{"location":"contracts/templates/DynamicAccessTemplate/#return-values","text":"Name Type Description length address conditionTypes array size ### removeLastTemplateCondition function removeLastTemplateCondition ( ) external returns ( address []) removeLastTemplateCondition removes last condition added to the template","title":"Return Values:"},{"location":"contracts/templates/DynamicAccessTemplate/#return-values_1","text":"Name Type Description conditionTypes existing in the array","title":"Return Values:"},{"location":"contracts/templates/EscrowComputeExecutionTemplate/","text":"Implementation of a Compute Execution Agreement Template EscrowComputeExecutionTemplate is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an on-chain SEA. The template is a composite of three basic conditions. Once the agreement is created, the consumer will lock an amount of tokens (as listed in the DID document - off-chain metadata) to the the lock reward contract which in turn will fire an event. ON the other hand the provider is listening to all the emitted events, the provider will catch the event and grant permissions to trigger a computation granting the execution via the ComputeExecutionCondition contract. The consumer now is able to trigger that computation by asking the off-chain gateway to start the execution of a compute workflow. Finally, the provider can call the escrow reward condition in order to release the payment. Every condition has a time window (time lock and time out). This implies that if the provider didn't grant the execution to the consumer within this time window, the consumer can ask for refund. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _computeExecutionConditionAddress , address _lockPaymentConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including service executor condition, lock reward and escrow reward conditions. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _computeExecutionConditionAddress address service executor condition contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward contract address","title":"EscrowComputeExecutionTemplate"},{"location":"contracts/templates/EscrowComputeExecutionTemplate/#functions","text":"","title":"Functions"},{"location":"contracts/templates/EscrowComputeExecutionTemplate/#initialize","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _computeExecutionConditionAddress , address _lockPaymentConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including service executor condition, lock reward and escrow reward conditions.","title":"initialize"},{"location":"contracts/templates/EscrowComputeExecutionTemplate/#parameters","text":"Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _computeExecutionConditionAddress address service executor condition contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward contract address","title":"Parameters:"},{"location":"contracts/templates/NFTAccessTemplate/","text":"Implementation of NFT Access Template The NFT Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing NFT holders to get access to Nevermined services. The template is a composite of 2 basic conditions: - NFT Holding Condition - Access Condition Once the agreement is created, the consumer can demonstrate is holding a NFT for a specific DID. If that's the case the Access condition can be fulfilled by the asset owner or provider and all the agreement is fulfilled. This can be used in scenarios where a data or services owner, can allow users to get access to exclusive services only when they demonstrate the are holding a specific number of NFTs of a DID. This is very useful in use cases like arts. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftHolderConditionAddress , address _accessConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address","title":"NFTAccessTemplate"},{"location":"contracts/templates/NFTAccessTemplate/#functions","text":"","title":"Functions"},{"location":"contracts/templates/NFTAccessTemplate/#initialize","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftHolderConditionAddress , address _accessConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions.","title":"initialize"},{"location":"contracts/templates/NFTAccessTemplate/#parameters","text":"Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address","title":"Parameters:"},{"location":"contracts/templates/NFTSalesTemplate/","text":"Implementation of NFT Sales Template The NFT Sales template supports an scenario where a NFT owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address","title":"NFTSalesTemplate"},{"location":"contracts/templates/NFTSalesTemplate/#functions","text":"","title":"Functions"},{"location":"contracts/templates/NFTSalesTemplate/#initialize","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions.","title":"initialize"},{"location":"contracts/templates/NFTSalesTemplate/#parameters","text":"Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address","title":"Parameters:"},{"location":"contracts/templates/TemplateStoreLibrary/","text":"Implementation of the Template Store Library. Templates are blueprints for modular SEAs. When creating an Agreement, a templateId defines the condition and reward types that are instantiated in the ConditionStore. Functions \u00b6 propose \u00b6 function propose ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal returns ( uint256 size ) propose new template Parameters: \u00b6 Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address Return Values: \u00b6 Name Type Description size struct TemplateStoreLibrary.TemplateList which is the index of the proposed template ### approve function approve ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal approve new template Parameters: \u00b6 Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address revoke \u00b6 function revoke ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal revoke new template Parameters: \u00b6 Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address approved template contract address","title":"TemplateStoreLibrary"},{"location":"contracts/templates/TemplateStoreLibrary/#functions","text":"","title":"Functions"},{"location":"contracts/templates/TemplateStoreLibrary/#propose","text":"function propose ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal returns ( uint256 size ) propose new template","title":"propose"},{"location":"contracts/templates/TemplateStoreLibrary/#parameters","text":"Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address","title":"Parameters:"},{"location":"contracts/templates/TemplateStoreLibrary/#return-values","text":"Name Type Description size struct TemplateStoreLibrary.TemplateList which is the index of the proposed template ### approve function approve ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal approve new template","title":"Return Values:"},{"location":"contracts/templates/TemplateStoreLibrary/#parameters_1","text":"Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address","title":"Parameters:"},{"location":"contracts/templates/TemplateStoreLibrary/#revoke","text":"function revoke ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal revoke new template","title":"revoke"},{"location":"contracts/templates/TemplateStoreLibrary/#parameters_2","text":"Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address approved template contract address","title":"Parameters:"},{"location":"contracts/templates/TemplateStoreManager/","text":"Implementation of the Template Store Manager. Templates are blueprints for modular SEAs. When creating an Agreement, a templateId defines the condition and reward types that are instantiated in the ConditionStore. This contract manages the life cycle of the template ( Propose \u2192 Approve \u2192 Revoke ). Functions \u00b6 initialize \u00b6 function initialize ( address _owner ) public initialize TemplateStoreManager Initializer Initializes Ownable. Only on contract creation. Parameters: \u00b6 Name Type Description _owner address refers to the owner of the contract proposeTemplate \u00b6 function proposeTemplate ( address _id ) external returns ( uint256 size ) proposeTemplate proposes a new template Parameters: \u00b6 Name Type Description _id address unique template identifier which is basically the template contract address approveTemplate \u00b6 function approveTemplate ( address _id ) external approveTemplate approves a template Parameters: \u00b6 Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) can approve this template. revokeTemplate \u00b6 function revokeTemplate ( address _id ) external revokeTemplate revoke a template Parameters: \u00b6 Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) or template owner can revoke this template. getTemplate \u00b6 function getTemplate ( address _id ) external returns ( enum TemplateStoreLibrary . TemplateState state , address owner , address lastUpdatedBy , uint256 blockNumberUpdated ) getTemplate get more information about a template Parameters: \u00b6 Name Type Description _id address unique template identifier which is basically the template contract address. Return Values: \u00b6 Name Type Description state address template status owner template owner lastUpdatedBy last updated by blockNumberUpdated last updated at. ### getTemplateListSize function getTemplateListSize ( ) external returns ( uint256 size ) getTemplateListSize number of templates Return Values: \u00b6 Name Type Description size number of templates ### isTemplateApproved function isTemplateApproved ( address _id ) external returns ( bool ) isTemplateApproved check whether the template is approved Parameters: \u00b6 Name Type Description _id address unique template identifier which is basically the template contract address. Return Values: \u00b6 Name Type Description true address if the template is approved","title":"TemplateStoreManager"},{"location":"contracts/templates/TemplateStoreManager/#functions","text":"","title":"Functions"},{"location":"contracts/templates/TemplateStoreManager/#initialize","text":"function initialize ( address _owner ) public initialize TemplateStoreManager Initializer Initializes Ownable. Only on contract creation.","title":"initialize"},{"location":"contracts/templates/TemplateStoreManager/#parameters","text":"Name Type Description _owner address refers to the owner of the contract","title":"Parameters:"},{"location":"contracts/templates/TemplateStoreManager/#proposetemplate","text":"function proposeTemplate ( address _id ) external returns ( uint256 size ) proposeTemplate proposes a new template","title":"proposeTemplate"},{"location":"contracts/templates/TemplateStoreManager/#parameters_1","text":"Name Type Description _id address unique template identifier which is basically the template contract address","title":"Parameters:"},{"location":"contracts/templates/TemplateStoreManager/#approvetemplate","text":"function approveTemplate ( address _id ) external approveTemplate approves a template","title":"approveTemplate"},{"location":"contracts/templates/TemplateStoreManager/#parameters_2","text":"Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) can approve this template.","title":"Parameters:"},{"location":"contracts/templates/TemplateStoreManager/#revoketemplate","text":"function revokeTemplate ( address _id ) external revokeTemplate revoke a template","title":"revokeTemplate"},{"location":"contracts/templates/TemplateStoreManager/#parameters_3","text":"Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) or template owner can revoke this template.","title":"Parameters:"},{"location":"contracts/templates/TemplateStoreManager/#gettemplate","text":"function getTemplate ( address _id ) external returns ( enum TemplateStoreLibrary . TemplateState state , address owner , address lastUpdatedBy , uint256 blockNumberUpdated ) getTemplate get more information about a template","title":"getTemplate"},{"location":"contracts/templates/TemplateStoreManager/#parameters_4","text":"Name Type Description _id address unique template identifier which is basically the template contract address.","title":"Parameters:"},{"location":"contracts/templates/TemplateStoreManager/#return-values","text":"Name Type Description state address template status owner template owner lastUpdatedBy last updated by blockNumberUpdated last updated at. ### getTemplateListSize function getTemplateListSize ( ) external returns ( uint256 size ) getTemplateListSize number of templates","title":"Return Values:"},{"location":"contracts/templates/TemplateStoreManager/#return-values_1","text":"Name Type Description size number of templates ### isTemplateApproved function isTemplateApproved ( address _id ) external returns ( bool ) isTemplateApproved check whether the template is approved","title":"Return Values:"},{"location":"contracts/templates/TemplateStoreManager/#parameters_5","text":"Name Type Description _id address unique template identifier which is basically the template contract address.","title":"Parameters:"},{"location":"contracts/templates/TemplateStoreManager/#return-values_2","text":"Name Type Description true address if the template is approved","title":"Return Values:"},{"location":"contracts/test/IPNFT/","text":"Functions \u00b6 initialize \u00b6 function initialize ( ) public setTokenURI \u00b6 function setTokenURI ( ) public mint \u00b6 function mint ( ) public returns ( bool ) mintWithoutTokenURI \u00b6 function mintWithoutTokenURI ( ) external transfer \u00b6 function transfer ( ) public Events \u00b6 TokenURIChanged \u00b6 event TokenURIChanged ( )","title":"IPNFT"},{"location":"contracts/test/IPNFT/#functions","text":"","title":"Functions"},{"location":"contracts/test/IPNFT/#initialize","text":"function initialize ( ) public","title":"initialize"},{"location":"contracts/test/IPNFT/#settokenuri","text":"function setTokenURI ( ) public","title":"setTokenURI"},{"location":"contracts/test/IPNFT/#mint","text":"function mint ( ) public returns ( bool )","title":"mint"},{"location":"contracts/test/IPNFT/#mintwithouttokenuri","text":"function mintWithoutTokenURI ( ) external","title":"mintWithoutTokenURI"},{"location":"contracts/test/IPNFT/#transfer","text":"function transfer ( ) public","title":"transfer"},{"location":"contracts/test/IPNFT/#events","text":"","title":"Events"},{"location":"contracts/test/IPNFT/#tokenurichanged","text":"event TokenURIChanged ( )","title":"TokenURIChanged"},{"location":"contracts/test/TestDisputeManager/","text":"Functions \u00b6 accepted \u00b6 function accepted ( ) public returns ( bool ) setAccepted \u00b6 function setAccepted ( ) public","title":"TestDisputeManager"},{"location":"contracts/test/TestDisputeManager/#functions","text":"","title":"Functions"},{"location":"contracts/test/TestDisputeManager/#accepted","text":"function accepted ( ) public returns ( bool )","title":"accepted"},{"location":"contracts/test/TestDisputeManager/#setaccepted","text":"function setAccepted ( ) public","title":"setAccepted"},{"location":"contracts/test/TestERC721/","text":"Functions \u00b6 initialize \u00b6 function initialize ( ) public mint \u00b6 function mint ( ) public","title":"TestERC721"},{"location":"contracts/test/TestERC721/#functions","text":"","title":"Functions"},{"location":"contracts/test/TestERC721/#initialize","text":"function initialize ( ) public","title":"initialize"},{"location":"contracts/test/TestERC721/#mint","text":"function mint ( ) public","title":"mint"},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerChangeFunctionSignature/","text":"Functions \u00b6 createAgreement \u00b6 function createAgreement ( ) public returns ( uint256 size )","title":"AgreementStoreManagerChangeFunctionSignature"},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerChangeFunctionSignature/#functions","text":"","title":"Functions"},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerChangeFunctionSignature/#createagreement","text":"function createAgreement ( ) public returns ( uint256 size )","title":"createAgreement"},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerChangeInStorage/","text":"","title":"AgreementStoreManagerChangeInStorage"},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerChangeInStorageAndLogic/","text":"","title":"AgreementStoreManagerChangeInStorageAndLogic"},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerExtraFunctionality/","text":"Functions \u00b6 dummyFunction \u00b6 function dummyFunction ( ) public returns ( bool )","title":"AgreementStoreManagerExtraFunctionality"},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerExtraFunctionality/#functions","text":"","title":"Functions"},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerExtraFunctionality/#dummyfunction","text":"function dummyFunction ( ) public returns ( bool )","title":"dummyFunction"},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerWithBug/","text":"Functions \u00b6 getAgreementListSize \u00b6 function getAgreementListSize ( ) public returns ( uint256 size )","title":"AgreementStoreManagerWithBug"},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerWithBug/#functions","text":"","title":"Functions"},{"location":"contracts/test/AgreementStoreManager/AgreementStoreManagerWithBug/#getagreementlistsize","text":"function getAgreementListSize ( ) public returns ( uint256 size )","title":"getAgreementListSize"},{"location":"contracts/test/ConditionStoreManager/ConditionStoreChangeFunctionSignature/","text":"Functions \u00b6 createCondition \u00b6 function createCondition ( ) public returns ( uint256 size )","title":"ConditionStoreChangeFunctionSignature"},{"location":"contracts/test/ConditionStoreManager/ConditionStoreChangeFunctionSignature/#functions","text":"","title":"Functions"},{"location":"contracts/test/ConditionStoreManager/ConditionStoreChangeFunctionSignature/#createcondition","text":"function createCondition ( ) public returns ( uint256 size )","title":"createCondition"},{"location":"contracts/test/ConditionStoreManager/ConditionStoreChangeInStorage/","text":"","title":"ConditionStoreChangeInStorage"},{"location":"contracts/test/ConditionStoreManager/ConditionStoreChangeInStorageAndLogic/","text":"","title":"ConditionStoreChangeInStorageAndLogic"},{"location":"contracts/test/ConditionStoreManager/ConditionStoreExtraFunctionality/","text":"Functions \u00b6 dummyFunction \u00b6 function dummyFunction ( ) public returns ( bool )","title":"ConditionStoreExtraFunctionality"},{"location":"contracts/test/ConditionStoreManager/ConditionStoreExtraFunctionality/#functions","text":"","title":"Functions"},{"location":"contracts/test/ConditionStoreManager/ConditionStoreExtraFunctionality/#dummyfunction","text":"function dummyFunction ( ) public returns ( bool )","title":"dummyFunction"},{"location":"contracts/test/ConditionStoreManager/ConditionStoreWithBug/","text":"Functions \u00b6 getConditionState \u00b6 function getConditionState ( ) public returns ( enum ConditionStoreLibrary . ConditionState )","title":"ConditionStoreWithBug"},{"location":"contracts/test/ConditionStoreManager/ConditionStoreWithBug/#functions","text":"","title":"Functions"},{"location":"contracts/test/ConditionStoreManager/ConditionStoreWithBug/#getconditionstate","text":"function getConditionState ( ) public returns ( enum ConditionStoreLibrary . ConditionState )","title":"getConditionState"},{"location":"contracts/test/DIDRegistry/DIDRegistryChangeFunctionSignature/","text":"Functions \u00b6 registerAttribute \u00b6 function registerAttribute ( ) public returns ( uint256 size )","title":"DIDRegistryChangeFunctionSignature"},{"location":"contracts/test/DIDRegistry/DIDRegistryChangeFunctionSignature/#functions","text":"","title":"Functions"},{"location":"contracts/test/DIDRegistry/DIDRegistryChangeFunctionSignature/#registerattribute","text":"function registerAttribute ( ) public returns ( uint256 size )","title":"registerAttribute"},{"location":"contracts/test/DIDRegistry/DIDRegistryChangeInStorage/","text":"","title":"DIDRegistryChangeInStorage"},{"location":"contracts/test/DIDRegistry/DIDRegistryChangeInStorageAndLogic/","text":"","title":"DIDRegistryChangeInStorageAndLogic"},{"location":"contracts/test/DIDRegistry/DIDRegistryExtraFunctionality/","text":"Functions \u00b6 getNumber \u00b6 function getNumber ( ) public returns ( uint256 )","title":"DIDRegistryExtraFunctionality"},{"location":"contracts/test/DIDRegistry/DIDRegistryExtraFunctionality/#functions","text":"","title":"Functions"},{"location":"contracts/test/DIDRegistry/DIDRegistryExtraFunctionality/#getnumber","text":"function getNumber ( ) public returns ( uint256 )","title":"getNumber"},{"location":"contracts/test/DIDRegistry/DIDRegistryWithBug/","text":"Functions \u00b6 registerAttribute \u00b6 function registerAttribute ( bytes32 _didSeed , bytes32 _checksum , address [] _url ) public returns ( uint256 size ) registerAttribute is called only by DID owner. this function registers DID attributes Parameters: \u00b6 Name Type Description _didSeed bytes32 refers to decentralized identifier (a byte32 length ID) _checksum bytes32 includes a one-way HASH calculated using the DDO content _url address[] refers to the attribute value","title":"DIDRegistryWithBug"},{"location":"contracts/test/DIDRegistry/DIDRegistryWithBug/#functions","text":"","title":"Functions"},{"location":"contracts/test/DIDRegistry/DIDRegistryWithBug/#registerattribute","text":"function registerAttribute ( bytes32 _didSeed , bytes32 _checksum , address [] _url ) public returns ( uint256 size ) registerAttribute is called only by DID owner. this function registers DID attributes","title":"registerAttribute"},{"location":"contracts/test/DIDRegistry/DIDRegistryWithBug/#parameters","text":"Name Type Description _didSeed bytes32 refers to decentralized identifier (a byte32 length ID) _checksum bytes32 includes a one-way HASH calculated using the DDO content _url address[] refers to the attribute value","title":"Parameters:"},{"location":"contracts/test/TemplateStoreManager/TemplateStoreChangeFunctionSignature/","text":"Functions \u00b6 proposeTemplate \u00b6 function proposeTemplate ( ) external returns ( uint256 size )","title":"TemplateStoreChangeFunctionSignature"},{"location":"contracts/test/TemplateStoreManager/TemplateStoreChangeFunctionSignature/#functions","text":"","title":"Functions"},{"location":"contracts/test/TemplateStoreManager/TemplateStoreChangeFunctionSignature/#proposetemplate","text":"function proposeTemplate ( ) external returns ( uint256 size )","title":"proposeTemplate"},{"location":"contracts/test/TemplateStoreManager/TemplateStoreChangeInStorage/","text":"","title":"TemplateStoreChangeInStorage"},{"location":"contracts/test/TemplateStoreManager/TemplateStoreChangeInStorageAndLogic/","text":"","title":"TemplateStoreChangeInStorageAndLogic"},{"location":"contracts/test/TemplateStoreManager/TemplateStoreExtraFunctionality/","text":"Functions \u00b6 dummyFunction \u00b6 function dummyFunction ( ) public returns ( bool )","title":"TemplateStoreExtraFunctionality"},{"location":"contracts/test/TemplateStoreManager/TemplateStoreExtraFunctionality/#functions","text":"","title":"Functions"},{"location":"contracts/test/TemplateStoreManager/TemplateStoreExtraFunctionality/#dummyfunction","text":"function dummyFunction ( ) public returns ( bool )","title":"dummyFunction"},{"location":"contracts/test/TemplateStoreManager/TemplateStoreWithBug/","text":"Functions \u00b6 getTemplateListSize \u00b6 function getTemplateListSize ( ) external returns ( uint256 size )","title":"TemplateStoreWithBug"},{"location":"contracts/test/TemplateStoreManager/TemplateStoreWithBug/#functions","text":"","title":"Functions"},{"location":"contracts/test/TemplateStoreManager/TemplateStoreWithBug/#gettemplatelistsize","text":"function getTemplateListSize ( ) external returns ( uint256 size )","title":"getTemplateListSize"},{"location":"contracts/test/libraries/DIDRegistryLibraryProxy/","text":"Functions \u00b6 areRoyaltiesValid \u00b6 function areRoyaltiesValid ( ) public returns ( bool ) updateDIDOwner \u00b6 function updateDIDOwner ( ) public update \u00b6 function update ( ) public returns ( uint256 size ) initializeNftConfig \u00b6 function initializeNftConfig ( ) public getDIDInfo \u00b6 function getDIDInfo ( ) public returns ( address owner , address creator , uint256 royalties )","title":"DIDRegistryLibraryProxy"},{"location":"contracts/test/libraries/DIDRegistryLibraryProxy/#functions","text":"","title":"Functions"},{"location":"contracts/test/libraries/DIDRegistryLibraryProxy/#areroyaltiesvalid","text":"function areRoyaltiesValid ( ) public returns ( bool )","title":"areRoyaltiesValid"},{"location":"contracts/test/libraries/DIDRegistryLibraryProxy/#updatedidowner","text":"function updateDIDOwner ( ) public","title":"updateDIDOwner"},{"location":"contracts/test/libraries/DIDRegistryLibraryProxy/#update","text":"function update ( ) public returns ( uint256 size )","title":"update"},{"location":"contracts/test/libraries/DIDRegistryLibraryProxy/#initializenftconfig","text":"function initializeNftConfig ( ) public","title":"initializeNftConfig"},{"location":"contracts/test/libraries/DIDRegistryLibraryProxy/#getdidinfo","text":"function getDIDInfo ( ) public returns ( address owner , address creator , uint256 royalties )","title":"getDIDInfo"},{"location":"contracts/test/libraries/EpochLibraryProxy/","text":"Functions \u00b6 create \u00b6 function create ( ) external","title":"EpochLibraryProxy"},{"location":"contracts/test/libraries/EpochLibraryProxy/#functions","text":"","title":"Functions"},{"location":"contracts/test/libraries/EpochLibraryProxy/#create","text":"function create ( ) external","title":"create"},{"location":"contracts/test/libraries/HashListLibraryProxy/","text":"Functions \u00b6 initialize \u00b6 function initialize ( ) public hash \u00b6 function hash ( ) public returns ( bytes32 ) add \u00b6 function add ( ) external returns ( bool ) add \u00b6 function add ( ) external returns ( bool ) update \u00b6 function update ( ) external returns ( bool ) index \u00b6 function index ( ) external returns ( bool ) has \u00b6 function has ( ) external returns ( bool ) remove \u00b6 function remove ( ) external returns ( bool ) get \u00b6 function get ( ) external returns ( bytes32 ) size \u00b6 function size ( ) external returns ( uint256 ) all \u00b6 function all ( ) external returns ( bytes32 []) indexOf \u00b6 function indexOf ( ) external returns ( uint256 ) ownedBy \u00b6 function ownedBy ( ) external returns ( address ) isIndexed \u00b6 function isIndexed ( ) external returns ( bool )","title":"HashListLibraryProxy"},{"location":"contracts/test/libraries/HashListLibraryProxy/#functions","text":"","title":"Functions"},{"location":"contracts/test/libraries/HashListLibraryProxy/#initialize","text":"function initialize ( ) public","title":"initialize"},{"location":"contracts/test/libraries/HashListLibraryProxy/#hash","text":"function hash ( ) public returns ( bytes32 )","title":"hash"},{"location":"contracts/test/libraries/HashListLibraryProxy/#add","text":"function add ( ) external returns ( bool )","title":"add"},{"location":"contracts/test/libraries/HashListLibraryProxy/#add_1","text":"function add ( ) external returns ( bool )","title":"add"},{"location":"contracts/test/libraries/HashListLibraryProxy/#update","text":"function update ( ) external returns ( bool )","title":"update"},{"location":"contracts/test/libraries/HashListLibraryProxy/#index","text":"function index ( ) external returns ( bool )","title":"index"},{"location":"contracts/test/libraries/HashListLibraryProxy/#has","text":"function has ( ) external returns ( bool )","title":"has"},{"location":"contracts/test/libraries/HashListLibraryProxy/#remove","text":"function remove ( ) external returns ( bool )","title":"remove"},{"location":"contracts/test/libraries/HashListLibraryProxy/#get","text":"function get ( ) external returns ( bytes32 )","title":"get"},{"location":"contracts/test/libraries/HashListLibraryProxy/#size","text":"function size ( ) external returns ( uint256 )","title":"size"},{"location":"contracts/test/libraries/HashListLibraryProxy/#all","text":"function all ( ) external returns ( bytes32 [])","title":"all"},{"location":"contracts/test/libraries/HashListLibraryProxy/#indexof","text":"function indexOf ( ) external returns ( uint256 )","title":"indexOf"},{"location":"contracts/test/libraries/HashListLibraryProxy/#ownedby","text":"function ownedBy ( ) external returns ( address )","title":"ownedBy"},{"location":"contracts/test/libraries/HashListLibraryProxy/#isindexed","text":"function isIndexed ( ) external returns ( bool )","title":"isIndexed"},{"location":"contracts/token/erc1155/NFTUpgradeable/","text":"Implementation of the basic standard multi-token. See https://eips.ethereum.org/EIPS/eip-1155 Originally based on code by Enjin: https://github.com/enjin/erc-1155 Available since v3.1. Functions \u00b6 __NFTUpgradeable_init \u00b6 function __NFTUpgradeable_init ( ) internal See {_setURI}. __ERC1155_init_unchained \u00b6 function __ERC1155_init_unchained ( ) internal uri \u00b6 function uri ( ) external returns ( string ) See {IERC1155MetadataURI-uri}. This implementation returns the same URI for all token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the \\{id\\} substring with the actual token type ID. burn \u00b6 function burn ( ) public burnBatch \u00b6 function burnBatch ( ) public balanceOf \u00b6 function balanceOf ( ) public returns ( uint256 ) See {IERC1155-balanceOf}. Requirements: account cannot be the zero address. balanceOf \u00b6 function balanceOf ( ) external returns ( uint256 ) Returns the amount of tokens of token type id owned by account . Requirements: account cannot be the zero address. balanceOfBatch \u00b6 function balanceOfBatch ( ) public returns ( uint256 []) See {IERC1155-balanceOfBatch}. Requirements: accounts and ids must have the same length. setApprovalForAll \u00b6 function setApprovalForAll ( ) public See {IERC1155-setApprovalForAll}. setProxyApproval \u00b6 function setProxyApproval ( ) public isApprovedForAll \u00b6 function isApprovedForAll ( ) public returns ( bool ) See {IERC1155-isApprovedForAll}. isHolder \u00b6 function isHolder ( ) public returns ( bool ) safeTransferFrom \u00b6 function safeTransferFrom ( ) public See {IERC1155-safeTransferFrom}. safeBatchTransferFrom \u00b6 function safeBatchTransferFrom ( ) public See {IERC1155-safeBatchTransferFrom}. _mint \u00b6 function _mint ( ) internal Creates amount tokens of token type id , and assigns them to account . Emits a {TransferSingle} event. Requirements: account cannot be the zero address. If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value. _mintBatch \u00b6 function _mintBatch ( ) internal xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}. Requirements: ids and amounts must have the same length. If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value. _burn \u00b6 function _burn ( ) internal Destroys amount tokens of token type id from account Requirements: account cannot be the zero address. account must have at least amount tokens of token type id . _burnBatch \u00b6 function _burnBatch ( ) internal xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}. Requirements: ids and amounts must have the same length. _beforeTokenTransfer \u00b6 function _beforeTokenTransfer ( ) internal Hook that is called before any token transfer. This includes minting and burning, as well as batched variants. The same hook is called on both single and batched variants. For single transfers, the length of the id and amount arrays will be 1. Calling conditions (for each id and amount pair): When from and to are both non-zero, amount of from 's tokens of token type id will be transferred to to . When from is zero, amount tokens of token type id will be minted for to . when to is zero, amount of from 's tokens of token type id will be burned. from and to are never both zero. ids and amounts have the same, non-zero length. To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]. Events \u00b6 ProxyApproval \u00b6 event ProxyApproval ( ) Event for recording proxy approvals.","title":"NFTUpgradeable"},{"location":"contracts/token/erc1155/NFTUpgradeable/#functions","text":"","title":"Functions"},{"location":"contracts/token/erc1155/NFTUpgradeable/#__nftupgradeable_init","text":"function __NFTUpgradeable_init ( ) internal See {_setURI}.","title":"__NFTUpgradeable_init"},{"location":"contracts/token/erc1155/NFTUpgradeable/#__erc1155_init_unchained","text":"function __ERC1155_init_unchained ( ) internal","title":"__ERC1155_init_unchained"},{"location":"contracts/token/erc1155/NFTUpgradeable/#uri","text":"function uri ( ) external returns ( string ) See {IERC1155MetadataURI-uri}. This implementation returns the same URI for all token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the \\{id\\} substring with the actual token type ID.","title":"uri"},{"location":"contracts/token/erc1155/NFTUpgradeable/#burn","text":"function burn ( ) public","title":"burn"},{"location":"contracts/token/erc1155/NFTUpgradeable/#burnbatch","text":"function burnBatch ( ) public","title":"burnBatch"},{"location":"contracts/token/erc1155/NFTUpgradeable/#balanceof","text":"function balanceOf ( ) public returns ( uint256 ) See {IERC1155-balanceOf}. Requirements: account cannot be the zero address.","title":"balanceOf"},{"location":"contracts/token/erc1155/NFTUpgradeable/#balanceof_1","text":"function balanceOf ( ) external returns ( uint256 ) Returns the amount of tokens of token type id owned by account . Requirements: account cannot be the zero address.","title":"balanceOf"},{"location":"contracts/token/erc1155/NFTUpgradeable/#balanceofbatch","text":"function balanceOfBatch ( ) public returns ( uint256 []) See {IERC1155-balanceOfBatch}. Requirements: accounts and ids must have the same length.","title":"balanceOfBatch"},{"location":"contracts/token/erc1155/NFTUpgradeable/#setapprovalforall","text":"function setApprovalForAll ( ) public See {IERC1155-setApprovalForAll}.","title":"setApprovalForAll"},{"location":"contracts/token/erc1155/NFTUpgradeable/#setproxyapproval","text":"function setProxyApproval ( ) public","title":"setProxyApproval"},{"location":"contracts/token/erc1155/NFTUpgradeable/#isapprovedforall","text":"function isApprovedForAll ( ) public returns ( bool ) See {IERC1155-isApprovedForAll}.","title":"isApprovedForAll"},{"location":"contracts/token/erc1155/NFTUpgradeable/#isholder","text":"function isHolder ( ) public returns ( bool )","title":"isHolder"},{"location":"contracts/token/erc1155/NFTUpgradeable/#safetransferfrom","text":"function safeTransferFrom ( ) public See {IERC1155-safeTransferFrom}.","title":"safeTransferFrom"},{"location":"contracts/token/erc1155/NFTUpgradeable/#safebatchtransferfrom","text":"function safeBatchTransferFrom ( ) public See {IERC1155-safeBatchTransferFrom}.","title":"safeBatchTransferFrom"},{"location":"contracts/token/erc1155/NFTUpgradeable/#_mint","text":"function _mint ( ) internal Creates amount tokens of token type id , and assigns them to account . Emits a {TransferSingle} event. Requirements: account cannot be the zero address. If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value.","title":"_mint"},{"location":"contracts/token/erc1155/NFTUpgradeable/#_mintbatch","text":"function _mintBatch ( ) internal xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}. Requirements: ids and amounts must have the same length. If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.","title":"_mintBatch"},{"location":"contracts/token/erc1155/NFTUpgradeable/#_burn","text":"function _burn ( ) internal Destroys amount tokens of token type id from account Requirements: account cannot be the zero address. account must have at least amount tokens of token type id .","title":"_burn"},{"location":"contracts/token/erc1155/NFTUpgradeable/#_burnbatch","text":"function _burnBatch ( ) internal xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}. Requirements: ids and amounts must have the same length.","title":"_burnBatch"},{"location":"contracts/token/erc1155/NFTUpgradeable/#_beforetokentransfer","text":"function _beforeTokenTransfer ( ) internal Hook that is called before any token transfer. This includes minting and burning, as well as batched variants. The same hook is called on both single and batched variants. For single transfers, the length of the id and amount arrays will be 1. Calling conditions (for each id and amount pair): When from and to are both non-zero, amount of from 's tokens of token type id will be transferred to to . When from is zero, amount tokens of token type id will be minted for to . when to is zero, amount of from 's tokens of token type id will be burned. from and to are never both zero. ids and amounts have the same, non-zero length. To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].","title":"_beforeTokenTransfer"},{"location":"contracts/token/erc1155/NFTUpgradeable/#events","text":"","title":"Events"},{"location":"contracts/token/erc1155/NFTUpgradeable/#proxyapproval","text":"event ProxyApproval ( ) Event for recording proxy approvals.","title":"ProxyApproval"}]}